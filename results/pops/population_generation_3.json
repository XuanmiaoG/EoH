[
     {
          "algorithm": "The new algorithm scores each item based on a combination of its value-to-weight ratio and an exponential term that accounts for the remaining capacity, prioritizing items with higher value-to-weight ratios and better utilization of the remaining capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    exp_term = np.exp(-(remaining_capacity - weight) / remaining_capacity)\n    score = value_to_weight_ratio + exp_term\n    return score",
          "objective": 0.00209,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a novel function combining the hyperbolic tangent of the value-to-weight ratio and the inverse of the remaining capacity, ensuring that items with higher value density and better utilization of the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    inverse_capacity = 1 / (remaining_capacity + 1e-9)\n    score = np.tanh(value_density) * inverse_capacity\n    return score",
          "objective": 0.00261,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm scores each item based on a combination of the hyperbolic tangent of the value-to-weight ratio, a sigmoid function of the normalized remaining capacity, and a logarithmic function of the item's value, prioritizing items with higher value density, better utilization of the remaining capacity, and higher absolute value.",
          "code": "import numpy as np\n\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    sigmoid_factor = sigmoid((remaining_capacity - weight) / remaining_capacity)\n    score = np.tanh(value_density) * sigmoid_factor * np.log(1 + value)\n    return score",
          "objective": 0.00266,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef sigmoid_capacity_factor(remaining_capacity, weight):\n    return 1 / (1 + np.exp(-(remaining_capacity - weight)))\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    sigmoid_factor = sigmoid_capacity_factor(remaining_capacity, weight)\n    score = value_density * sigmoid_factor\n    return score",
          "objective": 0.00304,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm scores each item based on a combination of the hyperbolic tangent of the value-to-weight ratio and a sigmoid function of the remaining capacity, prioritizing items with higher value density and better utilization of the remaining capacity.",
          "code": "import numpy as np\n\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    sigmoid_factor = sigmoid(remaining_capacity - weight)\n    score = np.tanh(value_density) * sigmoid_factor\n    return score",
          "objective": 0.00311,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a novel function combining the exponential decay of the remaining capacity and the logarithmic scaling of the value-to-weight ratio, ensuring that items with higher value density and better utilization of the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    decay_factor = np.exp(-(remaining_capacity - weight) / remaining_capacity)\n    score = value_density * np.log1p(decay_factor)\n    return score",
          "objective": 0.0036,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    score = value_density * np.exp(-capacity_utilization ** 2)\n    return score",
          "objective": 0.00504,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm scores each item based on a combination of its value-to-weight ratio and an exponential term that accounts for the remaining capacity, ensuring that items with higher value-to-weight ratios and better utilization of the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    exp_term = np.exp(-(remaining_capacity - weight) / remaining_capacity)\n    score = value_to_weight_ratio * exp_term\n    return score",
          "objective": 0.00536,
          "other_inf": null
     }
]