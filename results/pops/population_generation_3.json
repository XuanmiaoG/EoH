[
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a combination of their value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value and lower weight are prioritized while also considering the knapsack's remaining capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    penalty = np.exp(-remaining_capacity / weight)\n    score = value_to_weight_ratio * penalty\n    return score",
          "objective": -0.38318,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm scores items based on a sigmoid-weighted value-to-weight ratio, where the sigmoid function is applied to the ratio of the item's weight to the remaining capacity, ensuring that items with higher value density and lower relative weight are prioritized.",
          "code": "import numpy as np\n\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    weight_ratio = weight / remaining_capacity\n    score = value_density * sigmoid(-weight_ratio * 10)  # Adjusted sigmoid scaling\n    return score",
          "objective": -0.04921,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score based on the item's value, weight, and remaining capacity, using a logarithmic transformation of the value-to-weight ratio and a polynomial function of the remaining capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_ratio = remaining_capacity / weight\n    score = np.log1p(value_density) * (capacity_ratio ** 2)\n    return score",
          "objective": -0.04308,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_ratio = remaining_capacity / weight\n    score = value_density * np.exp(capacity_ratio)\n    return score",
          "objective": -0.0305,
          "other_inf": null
     }
]