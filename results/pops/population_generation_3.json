[
     {
          "algorithm": "The new algorithm calculates the score by considering the value-to-weight ratio and an exponential decay factor based on how much of the remaining capacity the item would use, favoring items that better utilize the available space.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Base score is the value-to-weight ratio\n    base_score = value / weight\n    # Exponential decay factor to prioritize items that fill more of the capacity\n    decay_factor = np.exp(-0.5 * (remaining_capacity - weight) / remaining_capacity)\n    score = base_score * (1 + decay_factor)\n    return score",
          "objective": 0.00164,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by combining the value-to-weight ratio with a linear adjustment based on the proportion of the remaining capacity that the item would occupy, giving preference to items that more closely match the available space.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    base_score = value / weight\n    # Linear adjustment factor based on how much of the remaining capacity is used\n    adjustment_factor = 1 + (weight / remaining_capacity) * 0.5\n    score = base_score * adjustment_factor\n    return score",
          "objective": 0.0019,
          "other_inf": null
     },
     {
          "algorithm": "",
          "code": "import numpy as np\n\ndef exponential_adjustment(x):\n    return 1 - np.exp(-x)\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the base score as the natural logarithm of the value-to-weight ratio\n    base_score = np.log(value / weight)\n    # Adjust the score by a factor that exponentially increases with how close the item brings us to the capacity\n    adjustment_factor = exponential_adjustment(weight / remaining_capacity)\n    score = base_score * (1 + adjustment_factor)\n    return score",
          "objective": 0.00201,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by incorporating a linear adjustment factor based on the ratio of the item's weight to the remaining capacity, alongside the logarithm of the value-to-weight ratio.",
          "code": "import numpy as np\n\ndef linear_adjustment(x):\n    return x / (1 + x)\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    base_score = np.log(value / weight)\n    adjustment_factor = linear_adjustment(weight / remaining_capacity)\n    score = base_score * (1 + adjustment_factor)\n    return score",
          "objective": 0.00226,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by combining the value-to-weight ratio with a penalty for items that do not closely match the remaining capacity, using an exponential decay to favor items that nearly fill the knapsack.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Base score is the value-to-weight ratio\n    base_score = value / weight\n    # Penalty factor decreases exponentially as the item's weight gets closer to the remaining capacity\n    penalty_factor = np.exp(-((remaining_capacity - weight) ** 2) / (2 * remaining_capacity))\n    score = base_score * (1 + penalty_factor)\n    return score",
          "objective": 0.00243,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score based on a linear combination of the value-to-weight ratio and an exponential penalty for the difference between the item's weight and the remaining capacity, encouraging a balance between high-value items and those that fit well within the current capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the base score as the value-to-weight ratio\n    base_score = value / weight\n    # Calculate the penalty for not perfectly filling the capacity using an exponential function\n    penalty = np.exp(-0.5 * (remaining_capacity - weight) ** 2)\n    # Combine the base score with the penalty\n    score = base_score + penalty\n    return score",
          "objective": 0.00252,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by prioritizing items that maximize the value per unit of remaining capacity, with an additional bonus for items that leave a small but non-zero remaining capacity, to balance between immediate value gain and future flexibility.",
          "code": "import numpy as np\n\ndef calculate_bonus(remaining_capacity_after):\n    if 0 < remaining_capacity_after <= 10:\n        return 1 + (10 - remaining_capacity_after) / 10\n    return 1\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    remaining_capacity_after = remaining_capacity - weight\n    base_score = value / (weight + 1)  # Adding 1 to avoid division by zero\n    bonus = calculate_bonus(remaining_capacity_after)\n    score = base_score * bonus\n    return score",
          "objective": 0.00255,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a score for each item based on its value-to-weight ratio, adjusted by the square root of the remaining capacity to prioritize items that fit better, and includes an exponential penalty for items that cannot be included.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    else:\n        # Adjusting the value-to-weight ratio with a factor that considers the square root of the remaining capacity\n        adjustment_factor = np.sqrt(remaining_capacity + 1)\n        score = (value / weight) * adjustment_factor\n        return score",
          "objective": 0.00257,
          "other_inf": null
     }
]