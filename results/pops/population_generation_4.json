[
     {
          "algorithm": "The new algorithm calculates the score by considering the value-to-weight ratio and an exponential decay factor based on how much of the remaining capacity the item would use, favoring items that better utilize the available space.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Base score is the value-to-weight ratio\n    base_score = value / weight\n    # Exponential decay factor to prioritize items that fill more of the capacity\n    decay_factor = np.exp(-0.5 * (remaining_capacity - weight) / remaining_capacity)\n    score = base_score * (1 + decay_factor)\n    return score",
          "objective": 0.00164,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by combining the value-to-weight ratio with a linear adjustment based on the proportion of the remaining capacity that the item would occupy, giving preference to items that more closely match the available space.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    base_score = value / weight\n    # Linear adjustment factor based on how much of the remaining capacity is used\n    adjustment_factor = 1 + (weight / remaining_capacity) * 0.5\n    score = base_score * adjustment_factor\n    return score",
          "objective": 0.0019,
          "other_inf": null
     },
     {
          "algorithm": "",
          "code": "import numpy as np\n\ndef exponential_adjustment(x):\n    return 1 - np.exp(-x)\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the base score as the natural logarithm of the value-to-weight ratio\n    base_score = np.log(value / weight)\n    # Adjust the score by a factor that exponentially increases with how close the item brings us to the capacity\n    adjustment_factor = exponential_adjustment(weight / remaining_capacity)\n    score = base_score * (1 + adjustment_factor)\n    return score",
          "objective": 0.00201,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by combining the value-to-weight ratio with an exponential adjustment based on the proportion of the remaining capacity that the item would occupy, giving a stronger preference to items that more closely match the available space.",
          "code": "import numpy as np\n\ndef exponential_adjustment(usage_ratio):\n    return 1 + np.exp(usage_ratio - 1)\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    base_score = value / weight\n    usage_ratio = weight / remaining_capacity\n    adjustment_factor = exponential_adjustment(usage_ratio)\n    score = base_score * adjustment_factor\n    return score",
          "objective": 0.00203,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by incorporating a linear adjustment factor based on the ratio of the item's weight to the remaining capacity, alongside the logarithm of the value-to-weight ratio.",
          "code": "import numpy as np\n\ndef linear_adjustment(x):\n    return x / (1 + x)\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    base_score = np.log(value / weight)\n    adjustment_factor = linear_adjustment(weight / remaining_capacity)\n    score = base_score * (1 + adjustment_factor)\n    return score",
          "objective": 0.00226,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by combining the value-to-weight ratio with a penalty for items that do not closely match the remaining capacity, using an exponential decay to favor items that nearly fill the knapsack.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Base score is the value-to-weight ratio\n    base_score = value / weight\n    # Penalty factor decreases exponentially as the item's weight gets closer to the remaining capacity\n    penalty_factor = np.exp(-((remaining_capacity - weight) ** 2) / (2 * remaining_capacity))\n    score = base_score * (1 + penalty_factor)\n    return score",
          "objective": 0.00243,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by considering the square root of the value-to-weight ratio, and then applying a discount factor that increases as the remaining capacity decreases, to favor items that maintain a higher flexibility for subsequent choices.",
          "code": "import numpy as np\n\ndef calculate_discount(remaining_capacity):\n    if remaining_capacity == 0:\n        return 1\n    return 1 - (1 / (1 + remaining_capacity))\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    base_score = np.sqrt(value / (weight + 1))  # Adding 1 to avoid division by zero\n    discount = calculate_discount(remaining_capacity)\n    score = base_score * discount\n    return score",
          "objective": 0.00248,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score based on a linear combination of the value-to-weight ratio and an exponential penalty for the difference between the item's weight and the remaining capacity, encouraging a balance between high-value items and those that fit well within the current capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the base score as the value-to-weight ratio\n    base_score = value / weight\n    # Calculate the penalty for not perfectly filling the capacity using an exponential function\n    penalty = np.exp(-0.5 * (remaining_capacity - weight) ** 2)\n    # Combine the base score with the penalty\n    score = base_score + penalty\n    return score",
          "objective": 0.00252,
          "other_inf": null
     }
]