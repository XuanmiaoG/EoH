[
     {
          "algorithm": "The new algorithm scores items based on their value-to-weight ratio multiplied by a logistic function of the ratio of the item's weight to the remaining capacity, prioritizing items with a high value-to-weight ratio and a weight that is a significant but not excessive fraction of the remaining capacity.",
          "code": "import numpy as np\n\ndef logistic(x):\n    return 1 / (1 + np.exp(-x))\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    weight_ratio = weight / remaining_capacity\n    logistic_factor = logistic(weight_ratio)\n    score = value_to_weight_ratio * logistic_factor\n    return score",
          "objective": 0.00183,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a combination of their value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value-to-weight ratios and better utilization of the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    penalty = 1 / (remaining_capacity - weight + 1)  # Penalty term to prioritize items that better utilize the remaining capacity\n    score = value_to_weight_ratio + penalty\n    return score",
          "objective": 0.00222,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on their value-to-weight ratio multiplied by a logarithmic factor of the remaining capacity, prioritizing items that not only have a high value-to-weight ratio but also leave more capacity for future items.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    log_factor = np.log(remaining_capacity + 1)  # Logarithmic factor to prioritize items that leave more capacity\n    score = value_to_weight_ratio * log_factor\n    return score",
          "objective": 0.00257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on their value-to-weight ratio multiplied by a sigmoid function of the remaining capacity, prioritizing items that have a high value-to-weight ratio and are more likely to fit well within the remaining capacity.",
          "code": "import numpy as np\n\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    sigmoid_factor = sigmoid(remaining_capacity - weight)\n    score = value_to_weight_ratio * sigmoid_factor\n    return score",
          "objective": 0.00296,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm scores items based on a combination of their value-to-weight ratio and a bonus for their value relative to the remaining capacity, prioritizing items that provide high value and fit well within the remaining capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    value_bonus = value / remaining_capacity\n    score = value_to_weight_ratio + value_bonus\n    return score",
          "objective": 0.00392,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a combination of their value-to-weight ratio and a logarithmic penalty for their weight relative to the remaining capacity, ensuring items with higher value-to-weight ratios and better utilization of the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    log_penalty = np.log(1 + (weight / remaining_capacity))\n    score = value_to_weight_ratio - log_penalty\n    return score",
          "objective": 0.00589,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a combination of their value-to-weight ratio and an exponential reward for their value relative to the remaining capacity, ensuring items with higher value-to-weight ratios and higher absolute value are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    exp_reward = np.exp(value / remaining_capacity)\n    score = value_to_weight_ratio * exp_reward\n    return score",
          "objective": 0.00608,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on their value-to-weight ratio adjusted by an exponential decay factor that penalizes items that leave too much remaining capacity unused, ensuring that items with higher value-to-weight ratios and better utilization of the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    decay_factor = np.exp(-(remaining_capacity - weight) / remaining_capacity)\n    score = value_to_weight_ratio * decay_factor\n    return score",
          "objective": 0.0062,
          "other_inf": null
     }
]