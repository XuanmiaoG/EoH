[
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the remaining capacity after placing the item\n    remaining_capacity = bins - item\n    \n    # Calculate the ratio of item size to remaining capacity\n    ratio = np.where(remaining_capacity > 0, item / (remaining_capacity + 1e-9), 0)\n    \n    # Calculate a penalty based on the exponential decay of remaining capacity\n    penalty = np.exp(-remaining_capacity / item)\n    \n    # Calculate a priority based on the closeness of the remaining capacity to the item size\n    priority = np.exp(-np.abs(remaining_capacity - item) / item)\n    \n    # Combine the penalty and priority with a dynamic weight based on the ratio\n    scores = (1 - ratio) * penalty + ratio * priority\n    \n    return scores",
          "objective": 0.01288,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm assigns a score to each bin based on a combination of the bin's remaining capacity, the item size, a penalty for bins with large remaining capacities, a reward for bins with remaining capacities close to the item size, and a dynamic weighting mechanism that adjusts based on the current distribution of bin capacities, aiming to minimize the number of used bins while optimizing load distribution.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the remaining capacity after placing the item\n    remaining_capacity = bins - item\n    \n    # Penalize bins with large remaining capacities to avoid fragmentation\n    penalty = np.where(remaining_capacity > 0, 1 / (remaining_capacity + 1e-9), 0)\n    \n    # Reward bins with remaining capacities close to the item size\n    reward = np.exp(-np.abs(remaining_capacity - item) / (item + 1e-9))\n    \n    # Encourage bins with smaller remaining capacities to balance the load\n    load_balance = 1 / (bins + 1e-9)\n    \n    # Dynamic weighting based on the distribution of bin capacities\n    mean_capacity = np.mean(bins)\n    std_capacity = np.std(bins)\n    weight_penalty = 0.4 + 0.2 * (std_capacity / (mean_capacity + 1e-9))\n    weight_reward = 0.3 - 0.1 * (std_capacity / (mean_capacity + 1e-9))\n    weight_load_balance = 0.3 - 0.1 * (std_capacity / (mean_capacity + 1e-9))\n    \n    # Combine the factors with dynamic weights to compute the final score\n    scores = weight_penalty * penalty + weight_reward * reward + weight_load_balance * load_balance\n    \n    # Set the score to -infinity for bins that cannot fit the item\n    scores[bins < item] = -np.inf\n    \n    return scores",
          "objective": 0.02546,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm assigns a score to each bin based on a combination of the bin's remaining capacity, the item size, a penalty for bins with large remaining capacities, and a reward for bins with remaining capacities close to the item size, aiming to minimize the number of used bins while optimizing load distribution.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the remaining capacity after placing the item\n    remaining_capacity = bins - item\n    \n    # Penalize bins with large remaining capacities to avoid fragmentation\n    penalty = np.where(remaining_capacity > 0, 1 / (remaining_capacity + 1e-9), 0)\n    \n    # Reward bins with remaining capacities close to the item size\n    reward = np.exp(-np.abs(remaining_capacity - item) / (item + 1e-9))\n    \n    # Encourage bins with smaller remaining capacities to balance the load\n    load_balance = 1 / (bins + 1e-9)\n    \n    # Combine the factors with weights to compute the final score\n    scores = 0.5 * penalty + 0.3 * reward + 0.2 * load_balance\n    \n    # Set the score to -infinity for bins that cannot fit the item\n    scores[bins < item] = -np.inf\n    \n    return scores",
          "objective": 0.02646,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm assigns a score to each bin based on a combination of the bin's remaining capacity, the item size, a penalty for bins with large remaining capacities, a reward for bins with remaining capacities close to the item size, and an additional factor that prioritizes bins with minimal remaining capacity to further optimize load distribution and minimize fragmentation.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the remaining capacity after placing the item\n    remaining_capacity = bins - item\n    \n    # Penalize bins with large remaining capacities to avoid fragmentation\n    penalty = np.where(remaining_capacity > 0, 1 / (remaining_capacity + 1e-9), 0)\n    \n    # Reward bins with remaining capacities close to the item size\n    reward = np.exp(-np.abs(remaining_capacity - item) / (item + 1e-9))\n    \n    # Encourage bins with smaller remaining capacities to balance the load\n    load_balance = 1 / (bins + 1e-9)\n    \n    # Prioritize bins with minimal remaining capacity to minimize fragmentation\n    minimal_capacity_priority = np.exp(-remaining_capacity / (item + 1e-9))\n    \n    # Combine the factors with weights to compute the final score\n    scores = 0.4 * penalty + 0.3 * reward + 0.2 * load_balance + 0.1 * minimal_capacity_priority\n    \n    # Set the score to -infinity for bins that cannot fit the item\n    scores[bins < item] = -np.inf\n    \n    return scores",
          "objective": 0.0335,
          "other_inf": null
     }
]