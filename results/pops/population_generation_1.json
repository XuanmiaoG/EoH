[
     {
          "algorithm": "Implementing a 'Best Constant' by searching over a fixed number of candidate positions distributed evenly in [0,1].",
          "code": "import numpy as np\n\ndef place_facilities(peaks, weights, k):\n    # {Implementing a 'Best Constant' by searching over a fixed number of candidate positions distributed evenly in [0,1].}\n    \n    candidate_positions = np.linspace(0, 1, 101)\n    facilities_positions = []\n    \n    for position in candidate_positions:\n        cost = np.sum(weights * np.abs(peaks - position))\n        facilities_positions.append((position, cost))\n    \n    # Sort by cost\n    facilities_positions.sort(key=lambda x: x[1])\n    \n    # Select the top k positions with the lowest cost\n    best_positions = [fac_position[0] for fac_position in facilities_positions[:k]]\n    \n    return facilities_positions",
          "objective": 0.07703,
          "other_inf": null
     },
     {
          "algorithm": "Implementing a 'Best Quantile Rule' by placing facilities at equally spaced quantiles of the weighted peaks.",
          "code": "import numpy as np\n\ndef place_facilities(peaks, weights, k):\n    # {Implementing a 'Best Quantile Rule' by placing facilities at equally spaced quantiles of the weighted peaks.}\n    \n    sorted_indices = np.argsort(peaks)\n    sorted_peaks = peaks[sorted_indices]\n    sorted_weights = weights[sorted_indices]\n    \n    cumulative_weights = np.cumsum(sorted_weights)\n    total_weight = cumulative_weights[-1]\n    \n    facilities_positions = []\n    for i in range(k):\n        target_weight = (i + 1) * total_weight / (k + 1)\n        quantile_index = np.searchsorted(cumulative_weights, target_weight)\n        facilities_positions.append(sorted_peaks[quantile_index])\n    \n    return facilities_positions",
          "objective": 2.09543,
          "other_inf": null
     },
     {
          "algorithm": "Implementing a 'Best Percentile Rule' by placing facilities at equally spaced quantiles.",
          "code": "import numpy as np\n\ndef place_facilities(peaks, weights, k):\n    # {Implementing a 'Best Percentile Rule' by placing facilities at equally spaced quantiles.}\n\n    sorted_peaks = np.sort(peaks)\n    facilities_positions = []\n    \n    for i in range(k):\n        frac = (i + 1) / (k + 1)\n        idx = int(frac * (len(peaks) - 1))\n        facilities_positions.append(sorted_peaks[idx])\n    \n    return facilities_positions",
          "objective": 2.12508,
          "other_inf": null
     },
     {
          "algorithm": "Implementing a 'Best Dictator Rule' by placing facilities at the peaks of the top k weighted agents.",
          "code": "import numpy as np\n\ndef place_facilities(peaks, weights, k):\n    # {Implementing a 'Best Dictator Rule' by placing facilities at the peaks of the top k weighted agents.}\n    \n    sorted_indices = np.argsort(weights)[-k:]  # Get indices of the top k weighted agents\n    facilities_positions = peaks[sorted_indices]  # Assign facility positions to their peaks\n    \n    return facilities_positions",
          "objective": 2.93137,
          "other_inf": null
     }
]