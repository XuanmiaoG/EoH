[
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    capacity_ratio = remaining_capacity / weight\n    score = value * capacity_ratio + (value / weight)\n    return float(score)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00107,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (weight + 1e-9)\n    capacity_ratio = remaining_capacity / (weight + 1e-9)\n    return (value_ratio * np.log(value + 1)) * (capacity_ratio ** 0.5)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00115,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_power_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    power_term = (value / weight) * (remaining_capacity - weight + 1)\n    score = np.sqrt(value * power_term) + (value / weight)\n    return float(score)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_power_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00117,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    normalized_value = value / (weight + 1e-9)\n    capacity_factor = np.sqrt(remaining_capacity - weight + 1)\n    return normalized_value * capacity_factor * (value ** 0.5)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00125,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_hybrid_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    return (value_density * np.sqrt(value)) * (1 + capacity_utilization)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_hybrid_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00126,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    return (value_density ** 1.5) * np.exp(capacity_utilization) * (value ** 0.5)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00141,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    ratio = value / weight\n    capacity_ratio = remaining_capacity / weight\n    return ratio * capacity_ratio * np.log(value + 1)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00154,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    normalized_value = value / np.sqrt(weight)\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    score = normalized_value * (1 + capacity_utilization)\n    return float(score)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00166,
          "other_inf": null
     },
     {
          "algorithm": "```\n",
          "code": "import numpy as np\n\ndef calculate_exponential_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    normalized_value = value / remaining_capacity\n    normalized_weight = weight / remaining_capacity\n    score = np.exp(normalized_value) / (1 + normalized_weight)\n    return float(score)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_exponential_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00192,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_new_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_ratio = weight / remaining_capacity\n    return (value_density ** 2) * (1 - capacity_ratio) * np.log(value + 1)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_new_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00215,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_harmonic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    harmonic_mean = 2 * value * remaining_capacity / (value + remaining_capacity)\n    score = harmonic_mean / (weight ** 0.5)\n    return float(score)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_harmonic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.0022,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    normalized_value = value / remaining_capacity\n    normalized_weight = weight / remaining_capacity\n    return (normalized_value * (1 - normalized_weight)) * (value / weight)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00247,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (value + weight)\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    return (value_ratio ** 3) * np.exp(capacity_utilization) * (1 + np.log(weight + 1))\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00257,
          "other_inf": null
     },
     {
          "algorithm": "```\n",
          "code": "import numpy as np\n\ndef calculate_hybrid_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_ratio = remaining_capacity / (remaining_capacity - weight + 1e-9)\n    return (value_density ** 2) * np.sqrt(capacity_ratio) * (1 + np.log(value + 1))\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_hybrid_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00283,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_new_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / (weight + 1e-9)\n    capacity_ratio = (remaining_capacity - weight) / remaining_capacity\n    return value_density * np.exp(capacity_ratio) * (value ** 0.25)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_new_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00312,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    normalized_value = value / (weight + 1e-9)\n    capacity_factor = np.sqrt(remaining_capacity - weight + 1)\n    score = normalized_value * capacity_factor * np.log(value + 1)\n    return float(score)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00313,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    capacity_ratio = remaining_capacity / (remaining_capacity + weight)\n    value_ratio = value / (value + weight)\n    return (value_ratio * capacity_ratio) * (value / weight)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.0032,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_power_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    ratio = value / weight\n    capacity_ratio = remaining_capacity / weight\n    return (ratio ** 2) * np.sqrt(capacity_ratio)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_power_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00327,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_exponential_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / (weight + 1e-9)\n    capacity_ratio = (remaining_capacity - weight) / remaining_capacity\n    score = np.exp(value_density) * (1 + capacity_ratio) * value\n    return float(score)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_exponential_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00329,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    ratio = value / weight\n    capacity_ratio = remaining_capacity / weight\n    return ratio * np.sqrt(capacity_ratio) * (1 + np.log(value + 1))\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00333,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    return value_density * np.exp(capacity_utilization) * (1 + np.log1p(value))\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00336,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_new_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (weight + 1e-9)\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    return value_ratio * np.exp(capacity_utilization) * (1 + np.sqrt(value))\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_new_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00355,
          "other_inf": null
     },
     {
          "algorithm": "```\n",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    return (value_density ** 2) * np.exp(capacity_utilization)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00359,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / weight\n    capacity_ratio = remaining_capacity / (remaining_capacity - weight + 1e-9)\n    return value_ratio * np.sqrt(capacity_ratio)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00385,
          "other_inf": null
     },
     {
          "algorithm": "```\n",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (value + weight)\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    return value_ratio * np.exp(capacity_utilization) * (value + remaining_capacity)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00411,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_ratio = weight / remaining_capacity\n    return (value_density * np.exp(-capacity_ratio)) + (value * (1 - capacity_ratio))\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00419,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    normalized_value = value / remaining_capacity\n    normalized_weight = weight / remaining_capacity\n    return (normalized_value * (1 - normalized_weight)) * (remaining_capacity - weight + 1)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00436,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    normalized_value = value / remaining_capacity\n    normalized_weight = weight / remaining_capacity\n    return (normalized_value * np.exp(1 - normalized_weight)) * (remaining_capacity - weight + 1)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00468,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    normalized_value = value / np.max([value, 1])\n    normalized_weight = weight / np.max([weight, 1])\n    remaining_ratio = remaining_capacity / (remaining_capacity + weight)\n    return (normalized_value / normalized_weight) * remaining_ratio\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00474,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    capacity_ratio = remaining_capacity / (weight + 1e-9)\n    value_density = value / (weight + 1e-9)\n    return (value_density * capacity_ratio) * np.sqrt(value)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00477,
          "other_inf": null
     },
     {
          "algorithm": "```\n",
          "code": "import numpy as np\n\ndef calculate_modified_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (value + weight + 1e-9)\n    capacity_usage = (remaining_capacity - weight) / remaining_capacity\n    return (value_ratio * np.exp(capacity_usage)) * (1 + np.log(value + 1))\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_modified_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00493,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    ratio = value / weight\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    return ratio * (1 + capacity_utilization)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00499,
          "other_inf": null
     }
]