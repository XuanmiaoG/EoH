[
     {
          "algorithm": "The new algorithm calculates a score for each item based on the logarithm of its value-to-weight ratio, scaled by the square root of the remaining capacity, to prioritize items that are more valuable per unit of weight and fit well within the available space.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the log of the value-to-weight ratio\n    log_value_per_weight = np.log(value / weight)\n    # Scale the score by the square root of the remaining capacity\n    score = log_value_per_weight * np.sqrt(remaining_capacity)\n    return score",
          "objective": 0.00016,
          "other_inf": null
     },
     {
          "algorithm": "",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the exponential of the value-to-weight ratio\n    exp_value_per_weight = np.exp(value / weight)\n    # Apply a penalty for using up capacity, inversely proportional to the remaining space after adding the item\n    capacity_penalty = 1 / (remaining_capacity - weight + 1)\n    # The final score is the exponential value per weight minus the capacity penalty\n    score = exp_value_per_weight - capacity_penalty\n    return score",
          "objective": 0.0002,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes items based on a score that combines the value-to-weight ratio and a penalty for items that are close to exceeding the remaining capacity, favoring items that fit well within the available space.",
          "code": "import numpy as np\n\ndef calculate_penalty(weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    else:\n        # Penalize items that are closer to the remaining capacity limit\n        return 1 / (remaining_capacity - weight + 1)\n\ndef score(weight, value, remaining_capacity):\n    value_to_weight_ratio = value / weight\n    penalty = calculate_penalty(weight, remaining_capacity)\n    score = value_to_weight_ratio + penalty\n    return score",
          "objective": 0.00043,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm prioritizes items based on a score that combines the value-to-weight ratio, a penalty for not fully utilizing the knapsack, and an additional bonus for selecting lighter items to increase the flexibility in future selections.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the value-to-weight ratio\n    value_per_weight = value / weight\n    # Calculate a penalty for not fully utilizing the knapsack, which decreases as the knapsack gets fuller\n    capacity_utilization_bonus = 1 - (remaining_capacity - weight) / remaining_capacity\n    # Additional bonus for lighter items to keep the knapsack flexible\n    lightness_bonus = 1 / (weight + 1)\n    # The final score is a combination of the value per weight, the bonus for better capacity utilization, and the lightness bonus\n    score = value_per_weight + capacity_utilization_bonus + lightness_bonus\n    return score",
          "objective": 0.00055,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by combining a logarithmic value-to-weight ratio with a quadratic penalty for the remaining capacity, aiming to balance high-value items with efficient use of space.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the logarithm of the value-to-weight ratio\n    log_value_per_weight = np.log(value / weight + 1)\n    # Apply a quadratic penalty for using up capacity\n    capacity_penalty = (remaining_capacity - weight) ** 2\n    # The final score is the logarithmic value per weight plus the inverse of the capacity penalty\n    score = log_value_per_weight + 1 / (capacity_penalty + 1)\n    return score",
          "objective": 0.00056,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes items based on a score that combines the value-to-weight ratio and the remaining capacity, favoring items that offer a higher value per unit of weight while also considering how close they bring the knapsack to its full capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the value-to-weight ratio\n    value_per_weight = value / weight\n    # Calculate a penalty for not fully utilizing the knapsack, which decreases as the knapsack gets fuller\n    capacity_utilization_bonus = 1 - (remaining_capacity - weight) / remaining_capacity\n    # The final score is a combination of the value per weight and the bonus for better capacity utilization\n    score = value_per_weight + capacity_utilization_bonus\n    return score",
          "objective": 0.00057,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm prioritizes items based on a score that combines the value-to-weight ratio, a logarithmic adjustment for the remaining capacity, and a penalty for heavier items, to balance between high-value items and efficient use of space.",
          "code": "import numpy as np\n\ndef adjusted_capacity_bonus(weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # A logarithmic bonus that increases as the item fills more of the knapsack\n    if remaining_capacity - weight > 0:\n        return np.log(remaining_capacity) - np.log(remaining_capacity - weight)\n    else:\n        return 0\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the value-to-weight ratio\n    value_per_weight = value / weight\n    # Apply an adjusted capacity bonus\n    capacity_bonus = adjusted_capacity_bonus(weight, remaining_capacity)\n    # Introduce a small penalty for heavier items to encourage selection of lighter items when values are similar\n    heavy_penalty = -np.sqrt(weight) / 100\n    # The final score is a combination of the value per weight, the adjusted capacity bonus, and the heavy item penalty\n    score = value_per_weight + capacity_bonus + heavy_penalty\n    return score",
          "objective": 0.00107,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by considering the value-to-weight ratio and applying a penalty that increases with the item's weight relative to the remaining capacity, while also adding a small bonus for items that are exactly the right size to fill the knapsack.",
          "code": "import numpy as np\n\ndef adjusted_penalty(weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # A penalty that becomes more severe as the item's weight approaches the remaining capacity\n    penalty = (weight / remaining_capacity) ** 2\n    # A small bonus for items that fit very well into the remaining space\n    bonus = 0.1 if abs(remaining_capacity - weight) < 5 else 0\n    return penalty, bonus\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    penalty, bonus = adjusted_penalty(weight, remaining_capacity)\n    # Combining value-to-weight ratio, penalty, and bonus\n    score = (value / weight) - penalty + bonus\n    return score",
          "objective": 0.00115,
          "other_inf": null
     }
]