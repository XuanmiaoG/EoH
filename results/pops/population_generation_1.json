[
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a combination of their value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value-to-weight ratios and better utilization of the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    penalty = 1 / (remaining_capacity - weight + 1)  # Penalty term to prioritize items that better utilize the remaining capacity\n    score = value_to_weight_ratio + penalty\n    return score",
          "objective": 0.00222,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on their value-to-weight ratio multiplied by a logarithmic factor of the remaining capacity, prioritizing items that not only have a high value-to-weight ratio but also leave more capacity for future items.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    log_factor = np.log(remaining_capacity + 1)  # Logarithmic factor to prioritize items that leave more capacity\n    score = value_to_weight_ratio * log_factor\n    return score",
          "objective": 0.00257,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm scores items based on a combination of their value-to-weight ratio and a bonus for their value relative to the remaining capacity, prioritizing items that provide high value and fit well within the remaining capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    value_bonus = value / remaining_capacity\n    score = value_to_weight_ratio + value_bonus\n    return score",
          "objective": 0.00392,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a combination of their value-to-weight ratio and a logarithmic penalty for their weight relative to the remaining capacity, ensuring items with higher value-to-weight ratios and better utilization of the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    log_penalty = np.log(1 + (weight / remaining_capacity))\n    score = value_to_weight_ratio - log_penalty\n    return score",
          "objective": 0.00589,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on their value-to-weight ratio adjusted by an exponential decay factor that penalizes items that leave too much remaining capacity unused, ensuring that items with higher value-to-weight ratios and better utilization of the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    decay_factor = np.exp(-(remaining_capacity - weight) / remaining_capacity)\n    score = value_to_weight_ratio * decay_factor\n    return score",
          "objective": 0.0062,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a combination of their value-to-weight ratio and a penalty for their weight relative to the remaining capacity, ensuring items that fit well and provide high value are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    weight_penalty = weight / remaining_capacity\n    score = value_to_weight_ratio - weight_penalty\n    return score",
          "objective": 0.00922,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    utilization_factor = (remaining_capacity - weight) / remaining_capacity\n    score = value_to_weight_ratio * (1 + utilization_factor)\n    return score",
          "objective": 0.0104,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on their value, adjusted by an exponential decay factor that penalizes items with weights closer to the remaining capacity, ensuring items with high value and moderate weight are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    decay_factor = np.exp(-weight / remaining_capacity)\n    score = value * decay_factor\n    return score",
          "objective": 0.01073,
          "other_inf": null
     }
]