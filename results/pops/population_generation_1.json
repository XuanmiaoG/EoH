[
     {
          "algorithm": "The new algorithm calculates a score based on the square root of the value, adjusted by the ratio of remaining capacity to item weight, and penalizes items that cannot fit into the knapsack.",
          "code": "import numpy as np\n\ndef calculate_adjusted_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    adjustment = (remaining_capacity / weight) ** 0.5\n    return np.sqrt(value) * adjustment\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_adjusted_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00017,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a score for each item based on its value-to-weight ratio and penalizes items that are significantly heavier than the remaining capacity, aiming to balance between maximizing value and efficiently using space.",
          "code": "import numpy as np\n\ndef adjusted_value_to_weight_ratio(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Penalize items that are much heavier compared to the remaining capacity\n    penalty_factor = 1 if weight <= remaining_capacity / 2 else (remaining_capacity / (2 * weight))\n    return (value / weight) * penalty_factor\n\ndef score(weight, value, remaining_capacity):\n    score = adjusted_value_to_weight_ratio(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00055,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a score for each item by considering its value-to-weight ratio and penalizing items based on the difference between their weight and the remaining capacity, with a higher penalty for items that are much lighter or heavier than the remaining space.",
          "code": "import numpy as np\n\ndef penalty_factor(weight, remaining_capacity):\n    if remaining_capacity == 0:\n        return 1\n    # Penalize more as the difference between weight and remaining capacity increases\n    penalty = abs(remaining_capacity - weight) / remaining_capacity\n    return 1 / (penalty + 1)\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the base score as the value-to-weight ratio\n    base_score = value / weight\n    # Adjust the score using the penalty factor\n    adjustment_factor = penalty_factor(weight, remaining_capacity)\n    score = base_score * adjustment_factor\n    return score",
          "objective": 0.00056,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score of an item based on its value-to-weight ratio, adjusted by a logarithmic function of the remaining capacity to favor items that are more valuable per unit weight as the knapsack fills up.",
          "code": "import numpy as np\n\ndef log_adjustment(remaining_capacity, weight):\n    if weight > remaining_capacity:\n        return -1e9\n    # The closer the remaining capacity is to the item's weight, the higher the adjustment factor.\n    adjustment_factor = np.log(remaining_capacity + 1) / (np.log(remaining_capacity - weight + 2))\n    return adjustment_factor\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    base_score = value / weight\n    adjustment = log_adjustment(remaining_capacity, weight)\n    score = base_score * adjustment\n    return score",
          "objective": 0.00063,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a score for each item by considering its value-to-weight ratio and penalizing items that are much heavier than the remaining capacity, to prioritize lighter items when the knapsack is nearly full.",
          "code": "import numpy as np\n\ndef adjusted_value_to_weight_ratio(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Penalize items more heavily based on how their weight compares to the remaining capacity\n    penalty_factor = 1 / (1 + np.exp((weight - remaining_capacity) / (remaining_capacity + 1)))\n    return (value / weight) * penalty_factor\n\ndef score(weight, value, remaining_capacity):\n    score = adjusted_value_to_weight_ratio(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00095,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by considering the value per unit weight, adding a linear penalty for items with weights closer to the remaining capacity, and applying a logarithmic enhancement factor for higher values.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the base score as the value divided by the weight\n    base_score = value / weight\n    # Apply a linear penalty that increases as the item's weight approaches the remaining capacity\n    penalty = 1 - (weight / (remaining_capacity + 1))\n    # Enhance the score using a logarithmic factor based on the value\n    enhancement_factor = np.log(value + 2)  # Adding 2 to handle log(1) = 0 case\n    score = base_score * penalty * enhancement_factor\n    return score",
          "objective": 0.00099,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a score for each item based on its value-to-weight ratio, adjusted by the remaining capacity of the knapsack, to prioritize items that offer the best value while fitting within the constraints.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the base score as the value-to-weight ratio\n    base_score = value / weight\n    # Adjust the score with a factor that increases as the remaining capacity decreases,\n    # making it more likely to pick items that fit better in the current capacity.\n    adjustment_factor = 1 + (remaining_capacity - weight) / (remaining_capacity + 1)\n    score = base_score * adjustment_factor\n    return score",
          "objective": 0.00158,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a score for each item by considering the ratio of its value to the square root of its weight, and applies a penalty based on how much of the remaining capacity it would use, encouraging a balance between high-value items and efficient space utilization.",
          "code": "import numpy as np\n\ndef adjusted_efficiency(weight, value):\n    return value / np.sqrt(weight)\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    item_efficiency = adjusted_efficiency(weight, value)\n    penalty = 1 - (weight / remaining_capacity) if remaining_capacity > 0 else 0\n    score = item_efficiency * penalty\n    return score",
          "objective": 0.0019,
          "other_inf": null
     }
]