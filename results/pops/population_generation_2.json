[
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_enhanced_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_ratio = remaining_capacity / weight\n    return value_density * np.log(value + 1) * (1 + capacity_ratio)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_enhanced_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00084,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_tanh_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_ratio = remaining_capacity / weight\n    return value_density * np.tanh(capacity_ratio) * (value + remaining_capacity)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_tanh_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00097,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    capacity_ratio = remaining_capacity / weight\n    return value * capacity_ratio\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00107,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_exponential_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_factor = np.exp(-weight / remaining_capacity)\n    return (value_density ** 3) * capacity_factor * (value + weight)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_exponential_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00112,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (weight + 1e-9)\n    capacity_utilization = weight / (remaining_capacity + 1e-9)\n    return (value_ratio ** 1.5) * np.exp(-capacity_utilization) * (value ** 0.8)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00118,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_logarithmic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (value + weight)\n    capacity_ratio = remaining_capacity / (remaining_capacity + weight)\n    return np.log(1 + value_ratio * capacity_ratio) * (value + remaining_capacity)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_logarithmic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00123,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_logistic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_fraction = weight / remaining_capacity\n    return value_density * (1 / (1 + np.exp(-capacity_fraction)))\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_logistic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00124,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_logarithmic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_factor = np.log(1 + remaining_capacity / weight)\n    return (value_density ** 2) * capacity_factor * np.sqrt(value)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_logarithmic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00125,
          "other_inf": null
     },
     {
          "algorithm": "```\n",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    return value_density * np.sqrt(value) * (1 + capacity_utilization)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00126,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    ratio = value / weight\n    capacity_ratio = remaining_capacity / weight\n    return ratio * capacity_ratio * np.log(value + 1)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00154,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_power_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (weight + 1e-9)\n    capacity_ratio = remaining_capacity / (weight + 1e-9)\n    return (value_ratio ** 2) * (capacity_ratio ** 0.5) * (value + remaining_capacity)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_power_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00168,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_hybrid_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (weight + 1e-9)\n    capacity_ratio = (remaining_capacity - weight) / (remaining_capacity + 1e-9)\n    return (value_ratio ** 2) * np.sqrt(capacity_ratio) * (value + weight)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_hybrid_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00184,
          "other_inf": null
     },
     {
          "algorithm": "```\n",
          "code": "import numpy as np\n\ndef calculate_dynamic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (weight + 1e-9)\n    capacity_ratio = remaining_capacity / (weight + 1e-9)\n    return value_ratio * np.log1p(capacity_ratio) * (value + weight)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_dynamic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00193,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_exponential_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_ratio = weight / remaining_capacity\n    return value_density * np.exp(-capacity_ratio) * (value * remaining_capacity)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_exponential_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00207,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef calculate_exponential_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_ratio = value / (weight + 1e-9)\n    capacity_ratio = (remaining_capacity - weight) / (remaining_capacity + 1e-9)\n    return np.exp(value_ratio) * (1 + capacity_ratio) * (value + remaining_capacity)\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_exponential_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00221,
          "other_inf": null
     },
     {
          "algorithm": "```\n",
          "code": "import numpy as np\n\ndef calculate_logistic_score(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    capacity_ratio = weight / remaining_capacity\n    return value_density * (1 / (1 + np.exp(-10 * (1 - capacity_ratio))))\n\ndef score(weight, value, remaining_capacity):\n    score = calculate_logistic_score(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00253,
          "other_inf": null
     }
]