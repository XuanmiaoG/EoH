[
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Score is based on the hyperbolic tangent of the value-to-weight ratio, scaled by the remaining capacity\n    value_to_weight = value / weight\n    score = np.tanh(value_to_weight) * remaining_capacity\n    return score",
          "objective": 0.00257,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on the exponential decay of the remaining capacity after including the item, weighted by the item's value-to-weight ratio, ensuring that items that maximize value while minimizing the impact on remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Score is based on the exponential decay of remaining capacity weighted by value-to-weight ratio\n    value_to_weight = value / weight\n    remaining_capacity_after = remaining_capacity - weight\n    decay_factor = np.exp(-remaining_capacity_after / remaining_capacity)\n    score = value_to_weight * decay_factor\n    return score",
          "objective": 0.0062,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on the logarithmic scaling of its value relative to the remaining capacity, combined with a penalty for the item's weight, prioritizing items that offer high value while minimizing the reduction in remaining capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Score is based on logarithmic scaling of value relative to remaining capacity and a weight penalty\n    value_ratio = value / remaining_capacity\n    log_value = np.log1p(value_ratio)\n    weight_penalty = np.exp(-weight / remaining_capacity)\n    score = log_value * weight_penalty\n    return score",
          "objective": 0.00862,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on the exponential decay of its weight relative to the remaining capacity, combined with its value, ensuring that lighter items with high value are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Score is based on the exponential decay of weight relative to remaining capacity, combined with value\n    weight_decay = np.exp(-weight / remaining_capacity)\n    score = value * weight_decay\n    return score",
          "objective": 0.01073,
          "other_inf": null
     }
]