[
     {
          "algorithm": "Use a median-based approach by splitting the peaks into k segments and placing the facilities at the median of each segment.",
          "code": "import numpy as np\n\ndef place_facilities(peaks, weights, k):\n    # {Use a median-based approach by splitting the peaks into k segments and placing the facilities at the median of each segment.}\n    \n    sorted_peaks = np.sort(peaks)\n    num_peaks = len(sorted_peaks)\n    facilities_positions = []\n    \n    segment_size = num_peaks // k\n    \n    for i in range(k):\n        if i == k - 1:  # Last segment may include leftovers\n            segment = sorted_peaks[i * segment_size:]\n        else:\n            segment = sorted_peaks[i * segment_size:(i + 1) * segment_size]\n        \n        facilities_positions.append(np.median(segment))\n    \n    return facilities_positions",
          "objective": 1.88169,
          "other_inf": null
     },
     {
          "algorithm": "Use a clustering approach by averaging peaks in k equally sized segments and placing facilities at the center of each segment.",
          "code": "import numpy as np\n\ndef place_facilities(peaks, weights, k):\n    # {Use a clustering approach by averaging peaks in k equally sized segments and placing facilities at the center of each segment.}\n    \n    sorted_peaks = np.sort(peaks)\n    num_peaks = len(sorted_peaks)\n    facilities_positions = []\n    \n    segment_size = num_peaks // k\n    \n    for i in range(k):\n        if i == k - 1:  # Last segment may include leftovers\n            segment = sorted_peaks[i * segment_size:]\n        else:\n            segment = sorted_peaks[i * segment_size:(i + 1) * segment_size]\n        \n        facilities_positions.append(np.mean(segment))\n    \n    return facilities_positions",
          "objective": 1.92439,
          "other_inf": null
     },
     {
          "algorithm": "Use a progressive approach to place facilities at equal intervals based on the weighted distribution of peaks.",
          "code": "import numpy as np\n\ndef place_facilities(peaks, weights, k):\n    # {Use a progressive approach to place facilities at equal intervals based on the weighted distribution of peaks.}\n    \n    sorted_peaks = np.sort(peaks)\n    total_weight = np.sum(weights)\n    cumulative_weight = np.cumsum(weights) / total_weight\n    \n    facilities_positions = []\n    \n    for i in range(k):\n        target = (i + 1) / (k + 1)  # Target cumulative weight for facility\n        idx = np.searchsorted(cumulative_weight, target)\n        facilities_positions.append(sorted_peaks[idx])\n    \n    return facilities_positions",
          "objective": 2.09543,
          "other_inf": null
     },
     {
          "algorithm": "For k facilities, place them at the k distinct quantiles of the sorted peaks.",
          "code": "import numpy as np\n\ndef place_facilities(peaks, weights, k):\n    # {For k facilities, place them at the k distinct quantiles of the sorted peaks.}\n    \n    sorted_peaks = np.sort(peaks)\n    facilities_positions = []\n    \n    for i in range(k):\n        frac = (i + 1) / (k + 1)\n        idx = int(frac * (len(peaks) - 1))\n        facilities_positions.append(sorted_peaks[idx])\n    \n    return facilities_positions",
          "objective": 2.12508,
          "other_inf": null
     }
]