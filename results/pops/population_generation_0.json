[
     {
          "algorithm": "The algorithm prioritizes items based on a score that combines the value-to-weight ratio and a penalty for items that are close to exceeding the remaining capacity, favoring items that fit well within the available space.",
          "code": "import numpy as np\n\ndef calculate_penalty(weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    else:\n        # Penalize items that are closer to the remaining capacity limit\n        return 1 / (remaining_capacity - weight + 1)\n\ndef score(weight, value, remaining_capacity):\n    value_to_weight_ratio = value / weight\n    penalty = calculate_penalty(weight, remaining_capacity)\n    score = value_to_weight_ratio + penalty\n    return score",
          "objective": 0.00043,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes items based on a score that combines the value-to-weight ratio and the remaining capacity, favoring items that offer a higher value per unit of weight while also considering how close they bring the knapsack to its full capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the value-to-weight ratio\n    value_per_weight = value / weight\n    # Calculate a penalty for not fully utilizing the knapsack, which decreases as the knapsack gets fuller\n    capacity_utilization_bonus = 1 - (remaining_capacity - weight) / remaining_capacity\n    # The final score is a combination of the value per weight and the bonus for better capacity utilization\n    score = value_per_weight + capacity_utilization_bonus\n    return score",
          "objective": 0.00057,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a score for each item based on its value-to-weight ratio, adjusted by the remaining capacity of the knapsack to prioritize items that fit better and have higher values.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Adjusting the score with a factor that considers the remaining capacity,\n    # giving a slight preference to items that are closer in size to the remaining space.\n    adjustment_factor = 1 + (remaining_capacity - weight) / (remaining_capacity + 1)\n    score = (value / weight) * adjustment_factor\n    return score",
          "objective": 0.00158,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a score for each item based on its value-to-weight ratio, adjusted by the remaining capacity to prioritize items that fit better within the constraints.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Adjust the score based on the value-to-weight ratio and a penalty for items that are closer to the remaining capacity limit\n    score = value / weight + (remaining_capacity - weight) / (remaining_capacity + 1)\n    return score",
          "objective": 0.00193,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm prioritizes items based on a score that combines the value-to-weight ratio with a penalty for items that are too large, encouraging a balance between selecting valuable and space-efficient items.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Combining value-to-weight ratio with a penalty for larger weights\n    score = (value / weight) - (weight / remaining_capacity)\n    return score",
          "objective": 0.00194,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a score for each item based on its value-to-weight ratio, adjusted by the remaining capacity of the knapsack, to prioritize items that offer the best value without exceeding the weight limit.",
          "code": "import numpy as np\n\ndef adjusted_ratio(value, weight, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    return (value / weight) * (1 - (weight / (remaining_capacity + 1)))\n\ndef score(weight, value, remaining_capacity):\n    score = adjusted_ratio(value, weight, remaining_capacity)\n    return score",
          "objective": 0.00348,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a score for each item based on a combination of its value, weight, and the remaining capacity of the knapsack, favoring items that offer the best value-to-weight ratio while also considering how much space they will occupy relative to what's left.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate a base score using the value-to-weight ratio.\n    base_score = value / weight\n    # Adjust the score based on the remaining capacity; less room left means more penalty for heavier items.\n    adjustment = 1 - (weight / remaining_capacity) if remaining_capacity > 0 else 0\n    score = base_score * adjustment\n    return score",
          "objective": 0.0035,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a score for each item based on its value, weight, and the remaining capacity of the knapsack, prioritizing items with higher values and lower weights, while penalizing those that do not fit.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Prioritize value and efficiency (value/weight), and slightly favor items that leave more room\n    score = value / weight + 0.01 * (remaining_capacity - weight)\n    return score",
          "objective": 0.00468,
          "other_inf": null
     }
]