[
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value and lower weight are prioritized while also considering the knapsack's remaining capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Score is a combination of value-to-weight ratio and a penalty term based on remaining capacity\n    value_to_weight_ratio = value / weight\n    penalty = 1 / (remaining_capacity - weight + 1)  # Penalize items that leave less remaining capacity\n    score = value_to_weight_ratio + penalty\n    return score",
          "objective": 0.00222,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value-to-weight ratios and better utilization of the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    penalty = 1 / (remaining_capacity - weight + 1)  # Penalty for unused capacity\n    score = value_to_weight_ratio - penalty\n    return score",
          "objective": 0.0033,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and its potential contribution to the remaining capacity, ensuring that items that fit well and provide high value are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Score is a combination of value-to-weight ratio and the fraction of remaining capacity it uses\n    value_to_weight = value / weight\n    capacity_usage = weight / remaining_capacity\n    # Combine the two factors with a weighted sum\n    score = 0.7 * value_to_weight + 0.3 * (1 - capacity_usage)\n    return score",
          "objective": 0.00464,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a combination of their value-to-weight ratio and a penalty for their weight relative to the remaining capacity, ensuring items that fit are prioritized while balancing value and weight.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight = value / weight\n    weight_penalty = weight / remaining_capacity\n    score = value_to_weight - weight_penalty\n    return score",
          "objective": 0.00922,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a novel score function combining the value-to-weight ratio and a penalty term for the remaining capacity, ensuring items with higher value density and better fit are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    penalty = 1 / (remaining_capacity - weight + 1)\n    score = value_density * penalty\n    return score",
          "objective": 0.01382,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a combination of their value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value and lower weight relative to the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    penalty = (remaining_capacity - weight) / remaining_capacity\n    score = value_to_weight_ratio * penalty\n    return score",
          "objective": 0.0239,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value and lower weight are prioritized while also considering the knapsack's current capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_per_weight = value / weight\n    penalty = np.exp(-remaining_capacity / weight)\n    score = value_per_weight * penalty\n    return score",
          "objective": 0.38868,
          "other_inf": null
     }
]