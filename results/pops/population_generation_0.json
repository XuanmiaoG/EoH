[
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and its potential to utilize the remaining capacity efficiently, prioritizing items that maximize value while fitting well within the remaining capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Score combines value-to-weight ratio and a penalty for underutilizing capacity\n    value_to_weight = value / weight\n    capacity_utilization = weight / remaining_capacity\n    score = value_to_weight * (1 + capacity_utilization)\n    return score",
          "objective": 0.00323,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a combination of their value-to-weight ratio and a penalty for their weight relative to the remaining capacity, ensuring items that fit are prioritized while maximizing value.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight = value / weight\n    weight_penalty = weight / remaining_capacity\n    score = value_to_weight - weight_penalty\n    return score",
          "objective": 0.00781,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores items based on a novel metric combining the value-to-weight ratio and a penalty for the remaining capacity, ensuring higher scores for items that maximize value while efficiently utilizing the knapsack capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    penalty = 1 / (remaining_capacity - weight + 1)\n    score = value_to_weight_ratio * penalty\n    return score",
          "objective": 0.01288,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value and lower weight are prioritized while also considering the knapsack's current capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Calculate the value-to-weight ratio\n    value_to_weight = value / weight\n    # Calculate a penalty term based on remaining capacity\n    penalty = np.exp(-remaining_capacity / weight)\n    # Combine the value-to-weight ratio and penalty to get the score\n    score = value_to_weight * penalty\n    return score",
          "objective": 0.38612,
          "other_inf": null
     }
]