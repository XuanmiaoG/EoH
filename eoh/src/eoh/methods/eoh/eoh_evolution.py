import re
import time
from ...llm.interface_LLM import InterfaceLLM


class Evolution:
    def __init__(
        self,
        api_endpoint: str | None,
        api_key: str | None,
        model_LLM: str | None,
        llm_use_local: bool,
        llm_local_url: str | None,
        debug_mode: bool,
        prompts: object,
        **kwargs: object,
    ) -> None:
        """
        Handles the generation of new algorithm code strings via a Large Language Model (LLM),
        using different prompting strategies (e.g., i1, e1, m1, etc.).

        Args:
            api_endpoint: (Optional) Remote LLM API endpoint.
            api_key: (Optional) API key for remote LLM usage.
            model_LLM: (Optional) Name or identifier of the LLM to use.
            llm_use_local: If True, use a local LLM server instead of a remote one.
            llm_local_url: (Optional) URL for the local LLM server.
            debug_mode: If True, prints additional debug information to the console.
            prompts: An object that provides various prompt strings (task, func_name, etc.).
            **kwargs: Additional parameters that may be needed by the LLM interface.

        Attributes:
            prompt_task (str): The main task or objective (e.g., "design an algorithm").
            prompt_func_name (str): The name of the Python function to be generated by the LLM.
            prompt_func_inputs (list[str]): The list of input parameter names for the function.
            prompt_func_outputs (list[str]): The list of output parameter names for the function.
            prompt_inout_inf (str): Additional prompt text about input-output formats.
            prompt_other_inf (str): Other auxiliary information for the prompt.
            joined_inputs (str): Comma-separated string of input parameter names.
            joined_outputs (str): Comma-separated string of output parameter names.
            interface_llm (InterfaceLLM): The interface to the local or remote LLM.

        """

        # Retrieve prompt info
        self.prompt_task: str = prompts.get_task()
        self.prompt_func_name: str = prompts.get_func_name()
        self.prompt_func_inputs: list[str] = prompts.get_func_inputs()
        self.prompt_func_outputs: list[str] = prompts.get_func_outputs()
        self.prompt_inout_inf: str = prompts.get_inout_inf()
        self.prompt_other_inf: str = prompts.get_other_inf()

        # Join inputs/outputs with commas if more than one
        if len(self.prompt_func_inputs) > 1:
            self.joined_inputs: str = ", ".join(
                "'" + s + "'" for s in self.prompt_func_inputs
            )
        else:
            self.joined_inputs: str = "'" + self.prompt_func_inputs[0] + "'"

        if len(self.prompt_func_outputs) > 1:
            self.joined_outputs: str = ", ".join(
                "'" + s + "'" for s in self.prompt_func_outputs
            )
        else:
            self.joined_outputs: str = "'" + self.prompt_func_outputs[0] + "'"

        self.api_endpoint: str | None = api_endpoint
        self.api_key: str | None = api_key
        self.model_LLM: str | None = model_LLM
        self.debug_mode: bool = debug_mode

        self.interface_llm = InterfaceLLM(
            self.api_endpoint,
            self.api_key,
            self.model_LLM,
            llm_use_local,
            llm_local_url,
            self.debug_mode,
        )

    ############################################################################
    # Prompt Generators
    ############################################################################

    def get_prompt_i1(self) -> str:
        """
        Build the prompt content for operator 'i1' (e.g., initial algorithm design).

        Returns:
            A string containing the prompt instructions for the LLM.
        """
        prompt_content = (
            self.prompt_task
            + "\n"
            + "First, describe your new algorithm and main steps in one sentence. "
            "The description must be inside a brace. Next, implement it in Python as a function named "
            + self.prompt_func_name
            + ". This function should accept "
            + str(len(self.prompt_func_inputs))
            + " input(s): "
            + self.joined_inputs
            + ". The function should return "
            + str(len(self.prompt_func_outputs))
            + " output(s): "
            + self.joined_outputs
            + ". "
            + self.prompt_inout_inf
            + " "
            + self.prompt_other_inf
            + "\n"
            + "Do not give additional explanations."
        )
        return prompt_content

    def get_prompt_e1(self, indivs: list[dict[str, str]]) -> str:
        """
        Build the prompt content for operator 'e1'.
        This uses a set of existing algorithms (indivs) to create something totally different.

        Args:
            indivs: List of dicts with 'algorithm' and 'code'.

        Returns:
            A string containing the prompt instructions for the LLM.
        """
        prompt_indiv = ""
        for i, indiv in enumerate(indivs):
            prompt_indiv += (
                f"No.{i + 1} algorithm and the corresponding code are: \n"
                + indiv["algorithm"]
                + "\n"
                + indiv["code"]
                + "\n"
            )

        prompt_content = (
            self.prompt_task
            + "\n"
            + "I have "
            + str(len(indivs))
            + " existing algorithms with their codes as follows: \n"
            + prompt_indiv
            + "Please help me create a new algorithm that has a totally different form from the given ones. \n"
            "First, describe your new algorithm and main steps in one sentence. "
            "The description must be inside a brace. Next, implement it in Python as a function named "
            + self.prompt_func_name
            + ". This function should accept "
            + str(len(self.prompt_func_inputs))
            + " input(s): "
            + self.joined_inputs
            + ". The function should return "
            + str(len(self.prompt_func_outputs))
            + " output(s): "
            + self.joined_outputs
            + ". "
            + self.prompt_inout_inf
            + " "
            + self.prompt_other_inf
            + "\n"
            + "Do not give additional explanations."
        )
        return prompt_content

    def get_prompt_e2(self, indivs: list[dict[str, str]]) -> str:
        """
        Build the prompt content for operator 'e2'.
        Motivates a new algorithm based on the common backbone idea of existing ones.

        Args:
            indivs: List of dicts with 'algorithm' and 'code'.

        Returns:
            A string containing the prompt instructions for the LLM.
        """
        prompt_indiv = ""
        for i, indiv in enumerate(indivs):
            prompt_indiv += (
                f"No.{i + 1} algorithm and the corresponding code are: \n"
                + indiv["algorithm"]
                + "\n"
                + indiv["code"]
                + "\n"
            )

        prompt_content = (
            self.prompt_task
            + "\n"
            + "I have "
            + str(len(indivs))
            + " existing algorithms with their codes as follows: \n"
            + prompt_indiv
            + "Please help me create a new algorithm that has a totally different form from the given ones but can be motivated from them. \n"
            "Firstly, identify the common backbone idea in the provided algorithms. Secondly, based on the backbone idea describe your new algorithm in one sentence. "
            "The description must be inside a brace. Thirdly, implement it in Python as a function named "
            + self.prompt_func_name
            + ". This function should accept "
            + str(len(self.prompt_func_inputs))
            + " input(s): "
            + self.joined_inputs
            + ". The function should return "
            + str(len(self.prompt_func_outputs))
            + " output(s): "
            + self.joined_outputs
            + ". "
            + self.prompt_inout_inf
            + " "
            + self.prompt_other_inf
            + "\n"
            + "Do not give additional explanations."
        )
        return prompt_content

    def get_prompt_m1(self, indiv1: dict[str, str]) -> str:
        """
        Build the prompt content for operator 'm1'.
        Creates a new algorithm as a modified version of the given one.

        Args:
            indiv1: A dict with 'algorithm' and 'code'.

        Returns:
            A string containing the prompt instructions for the LLM.
        """
        prompt_content = (
            self.prompt_task
            + "\n"
            + "I have one algorithm with its code as follows. Algorithm description: "
            + indiv1["algorithm"]
            + "\nCode:\n"
            + indiv1["code"]
            + "\nPlease assist me in creating a new algorithm that has a different form "
            "but can be a modified version of the algorithm provided. \n"
            "First, describe your new algorithm and main steps in one sentence. "
            "The description must be inside a brace. Next, implement it in Python as a function named "
            + self.prompt_func_name
            + ". This function should accept "
            + str(len(self.prompt_func_inputs))
            + " input(s): "
            + self.joined_inputs
            + ". The function should return "
            + str(len(self.prompt_func_outputs))
            + " output(s): "
            + self.joined_outputs
            + ". "
            + self.prompt_inout_inf
            + " "
            + self.prompt_other_inf
            + "\n"
            + "Do not give additional explanations."
        )
        return prompt_content

    def get_prompt_m2(self, indiv1: dict[str, str]) -> str:
        """
        Build the prompt content for operator 'm2'.
        Creates a new algorithm that adjusts parameter settings of the given one.

        Args:
            indiv1: A dict with 'algorithm' and 'code'.

        Returns:
            A string containing the prompt instructions for the LLM.
        """
        prompt_content = (
            self.prompt_task
            + "\n"
            + "I have one algorithm with its code as follows. Algorithm description: "
            + indiv1["algorithm"]
            + "\nCode:\n"
            + indiv1["code"]
            + "\nPlease identify the main algorithm parameters and assist me in creating a new algorithm "
            "that has a different parameter settings of the score function provided. \n"
            "First, describe your new algorithm and main steps in one sentence. "
            "The description must be inside a brace. Next, implement it in Python as a function named "
            + self.prompt_func_name
            + ". This function should accept "
            + str(len(self.prompt_func_inputs))
            + " input(s): "
            + self.joined_inputs
            + ". The function should return "
            + str(len(self.prompt_func_outputs))
            + " output(s): "
            + self.joined_outputs
            + ". "
            + self.prompt_inout_inf
            + " "
            + self.prompt_other_inf
            + "\n"
            + "Do not give additional explanations."
        )
        return prompt_content

    def get_prompt_m3(self, indiv1: dict[str, str]) -> str:
        """
        Build the prompt content for operator 'm3'.
        Simplifies components of the given code to enhance generalization.

        Args:
            indiv1: A dict with 'algorithm' and 'code'.

        Returns:
            A string containing the prompt instructions for the LLM.
        """
        prompt_content = (
            "First, you need to identify the main components in the function below. "
            "Next, analyze whether any of these components can be overfit to the in-distribution instances. "
            "Then, based on your analysis, simplify the components to enhance the generalization "
            "to potential out-of-distribution instances. Finally, provide the revised code, "
            "keeping the function name, inputs, and outputs unchanged. \n"
            + indiv1["code"]
            + "\n"
            + self.prompt_inout_inf
            + "\n"
            + "Do not give additional explanations."
        )
        return prompt_content

    def get_prompt_h1(self, indivs: list[dict[str, str]]) -> str:
        """
        Build the prompt content for operator 'h1'.
        Creates a new hybrid algorithm by integrating multiple algorithms.

        Args:
            indivs: List of dicts with 'algorithm' and 'code'.

        Returns:
            A string containing the prompt instructions for the LLM.
        """
        prompt_indiv = ""
        for i, indiv in enumerate(indivs):
            prompt_indiv += (
                f"No.{i + 1} algorithm and the corresponding code are: \n"
                + indiv["algorithm"]
                + "\n"
                + indiv["code"]
                + "\n"
            )

        prompt_content = (
            self.prompt_task
            + "\n"
            + "I have "
            + str(len(indivs))
            + " existing algorithms with their codes as follows: \n"
            + prompt_indiv
            + "Please create a new hybrid algorithm by:\n"
            "1. Identifying the unique strengths of each algorithm\n"
            "2. Combining their complementary features\n"
            "3. Adding novel elements to improve the combination\n\n"
            "First, describe your hybrid algorithm and its integration approach in one sentence. "
            "The description must be inside a brace. Next, implement it in Python as a function named "
            + self.prompt_func_name
            + ". This function should accept "
            + str(len(self.prompt_func_inputs))
            + " input(s): "
            + self.joined_inputs
            + ". The function should return "
            + str(len(self.prompt_func_outputs))
            + " output(s): "
            + self.joined_outputs
            + ". "
            + self.prompt_inout_inf
            + " "
            + self.prompt_other_inf
            + "\n"
            + "Do not give additional explanations."
        )
        return prompt_content

    def get_prompt_f1(self, indiv1: dict[str, str], failure_cases: str) -> str:
        """
        Build the prompt content for operator 'f1'.
        Improves the algorithm by analyzing and addressing its failure cases.

        Args:
            indiv1: A dict with 'algorithm' and 'code'.
            failure_cases: A string describing known failure scenarios.

        Returns:
            A string containing the prompt instructions for the LLM.
        """
        prompt_content = (
            self.prompt_task
            + "\n"
            + "I have one algorithm with its code as follows. Algorithm description: "
            + indiv1["algorithm"]
            + "\nCode:\n"
            + indiv1["code"]
            + "\nFailure cases:\n"
            + failure_cases
            + "\n\n"
            "Please create an improved algorithm by:\n"
            "1. Analyzing the patterns in failure cases\n"
            "2. Identifying the root causes of poor performance\n"
            "3. Designing specific mechanisms to address these weaknesses\n\n"
            "First, describe your improved algorithm in one sentence. "
            "The description must be inside a brace. Next, implement it in Python as a function named "
            + self.prompt_func_name
            + ". This function should accept "
            + str(len(self.prompt_func_inputs))
            + " input(s): "
            + self.joined_inputs
            + ". The function should return "
            + str(len(self.prompt_func_outputs))
            + " output(s): "
            + self.joined_outputs
            + ". "
            + self.prompt_inout_inf
            + " "
            + self.prompt_other_inf
            + "\n"
            + "Do not give additional explanations."
        )
        return prompt_content

    def get_prompt_c1(self, indiv1: dict[str, str], constraints: str) -> str:
        """
        Build the prompt content for operator 'c1'.
        Creates a constraint-focused algorithm by addressing specified constraints.

        Args:
            indiv1: A dict with 'algorithm' and 'code'.
            constraints: A string describing the critical constraints to handle.

        Returns:
            A string containing the prompt instructions for the LLM.
        """
        prompt_content = (
            self.prompt_task
            + "\n"
            + "I have one algorithm with its code as follows. Algorithm description: "
            + indiv1["algorithm"]
            + "\nCode:\n"
            + indiv1["code"]
            + "\nCritical constraints to address:\n"
            + constraints
            + "\n\n"
            "Please create a constraint-optimized algorithm by:\n"
            "1. Analyzing how the current algorithm handles these constraints\n"
            "2. Designing specialized mechanisms for constraint satisfaction\n"
            "3. Balancing constraint handling with overall performance\n\n"
            "First, describe your constraint-focused algorithm in one sentence. "
            "The description must be inside a brace. Next, implement it in Python as a function named "
            + self.prompt_func_name
            + ". This function should accept "
            + str(len(self.prompt_func_inputs))
            + " input(s): "
            + self.joined_inputs
            + ". The function should return "
            + str(len(self.prompt_func_outputs))
            + " output(s): "
            + self.joined_outputs
            + ". "
            + self.prompt_inout_inf
            + " "
            + self.prompt_other_inf
            + "\n"
            + "Do not give additional explanations."
        )
        return prompt_content

    def get_prompt_p1(self, indiv1: dict[str, str], complexity_target: str) -> str:
        """
        Build the prompt content for operator 'p1'.
        Increases complexity layers of the given algorithm.

        Args:
            indiv1: A dict with 'algorithm' and 'code'.
            complexity_target: Description of how to add complexity.

        Returns:
            A string containing the prompt instructions for the LLM.
        """
        prompt_content = (
            self.prompt_task
            + "\n"
            + "I have one algorithm with its code as follows. Algorithm description: "
            + indiv1["algorithm"]
            + "\nCode:\n"
            + indiv1["code"]
            + "\nTarget complexity aspects:\n"
            + complexity_target
            + "\n\n"
            "Please create an enhanced algorithm by:\n"
            "1. Starting with the core mechanism of the base algorithm\n"
            "2. Adding complexity layers that address: " + complexity_target + "\n"
            "3. Maintaining interpretability and efficiency\n\n"
            "First, describe your progressively enhanced algorithm in one sentence. "
            "The description must be inside a brace. Next, implement it in Python as a function named "
            + self.prompt_func_name
            + ". This function should accept "
            + str(len(self.prompt_func_inputs))
            + " input(s): "
            + self.joined_inputs
            + ". The function should return "
            + str(len(self.prompt_func_outputs))
            + " output(s): "
            + self.joined_outputs
            + ". "
            + self.prompt_inout_inf
            + " "
            + self.prompt_other_inf
            + "\n"
            + "Do not give additional explanations."
        )
        return prompt_content

    ############################################################################
    # Core Response Handling
    ############################################################################

    def _get_alg(self, prompt_content: str) -> list[str]:
        """
        Internal helper to query the LLM with 'prompt_content', parse the returned
        'algorithm' description (within braces) and the 'code' snippet.

        Returns a list [ code_all, algorithm ], where:
            - code_all (str): The discovered code plus the returned variables.
            - algorithm (str): The single-sentence description from braces.

        Example math formula (illustrative):
            If R is the raw LLM response and M is the parsing method,
            then:

                output = M(R)

            The complexity of the regex parsing is typically O(len(R)).

        Args:
            prompt_content: The prompt string to send to the LLM.

        Returns:
            A list of two strings: [code_all, algorithm].
        """
        response: str = self.interface_llm.get_response(prompt_content)

        # Attempt to extract the algorithm description (anything within curly braces)
        algorithm_matches = re.findall(r"\{(.*)\}", response, re.DOTALL)
        if len(algorithm_matches) == 0:
            # fallback checks
            if "python" in response:
                algorithm_matches = re.findall(r"^.*?(?=python)", response, re.DOTALL)
            elif "import" in response:
                algorithm_matches = re.findall(r"^.*?(?=import)", response, re.DOTALL)
            else:
                algorithm_matches = re.findall(r"^.*?(?=def)", response, re.DOTALL)

        # Attempt to extract the code snippet
        code_matches = re.findall(r"import.*return", response, re.DOTALL)
        if len(code_matches) == 0:
            code_matches = re.findall(r"def.*return", response, re.DOTALL)

        n_retry: int = 1
        while len(algorithm_matches) == 0 or len(code_matches) == 0:
            if self.debug_mode:
                print(
                    "Error: algorithm or code not identified, wait 1s and retrying ... "
                )
            time.sleep(1)

            response = self.interface_llm.get_response(prompt_content)
            algorithm_matches = re.findall(r"\{(.*)\}", response, re.DOTALL)
            if len(algorithm_matches) == 0:
                if "python" in response:
                    algorithm_matches = re.findall(
                        r"^.*?(?=python)", response, re.DOTALL
                    )
                elif "import" in response:
                    algorithm_matches = re.findall(
                        r"^.*?(?=import)", response, re.DOTALL
                    )
                else:
                    algorithm_matches = re.findall(r"^.*?(?=def)", response, re.DOTALL)

            code_matches = re.findall(r"import.*return", response, re.DOTALL)
            if len(code_matches) == 0:
                code_matches = re.findall(r"def.*return", response, re.DOTALL)

            if n_retry > 3:
                break
            n_retry += 1

        # Fallback to the first matched strings
        algorithm: str = algorithm_matches[0] if algorithm_matches else ""
        code: str = code_matches[0] if code_matches else ""

        # Append function outputs to code snippet (the original logic merges them)
        code_all = code + " " + ", ".join(s for s in self.prompt_func_outputs)
        return [code_all, algorithm]

    ############################################################################
    # Exposed Methods (Operators)
    ############################################################################

    def i1(self) -> list[str]:
        """
        Operator 'i1': Generate an initial algorithm from scratch (no parents).

        Returns:
            [code_all, algorithm], both strings.
        """
        prompt_content = self.get_prompt_i1()

        if self.debug_mode:
            print(
                "\n >>> check prompt for creating algorithm using [ i1 ] : \n",
                prompt_content,
            )
            print(">>> Press 'Enter' to continue")
            input()

        code_all, algorithm = self._get_alg(prompt_content)

        if self.debug_mode:
            print("\n >>> check designed algorithm: \n", algorithm)
            print("\n >>> check designed code: \n", code_all)
            print(">>> Press 'Enter' to continue")
            input()

        return [code_all, algorithm]

    def e1(self, parents: list[dict[str, str]]) -> list[str]:
        """
        Operator 'e1': Generate a new algorithm that is totally different
        from the given parents' algorithms.

        Args:
            parents: A list of parent algorithm dicts.

        Returns:
            [code_all, algorithm], both strings.
        """
        prompt_content = self.get_prompt_e1(parents)

        if self.debug_mode:
            print(
                "\n >>> check prompt for creating algorithm using [ e1 ] : \n",
                prompt_content,
            )
            print(">>> Press 'Enter' to continue")
            input()

        code_all, algorithm = self._get_alg(prompt_content)

        if self.debug_mode:
            print("\n >>> check designed algorithm: \n", algorithm)
            print("\n >>> check designed code: \n", code_all)
            print(">>> Press 'Enter' to continue")
            input()

        return [code_all, algorithm]

    def e2(self, parents: list[dict[str, str]]) -> list[str]:
        """
        Operator 'e2': Generate a new algorithm that is different yet
        motivated by the common backbone idea of given parents.

        Args:
            parents: A list of parent algorithm dicts.

        Returns:
            [code_all, algorithm], both strings.
        """
        prompt_content = self.get_prompt_e2(parents)

        if self.debug_mode:
            print(
                "\n >>> check prompt for creating algorithm using [ e2 ] : \n",
                prompt_content,
            )
            print(">>> Press 'Enter' to continue")
            input()

        code_all, algorithm = self._get_alg(prompt_content)

        if self.debug_mode:
            print("\n >>> check designed algorithm: \n", algorithm)
            print("\n >>> check designed code: \n", code_all)
            print(">>> Press 'Enter' to continue")
            input()

        return [code_all, algorithm]

    def m1(self, parents: dict[str, str]) -> list[str]:
        """
        Operator 'm1': Create a new algorithm as a modified version of 'parents'.

        Args:
            parents: A dictionary with 'algorithm' and 'code'.

        Returns:
            [code_all, algorithm], both strings.
        """
        prompt_content = self.get_prompt_m1(parents)

        if self.debug_mode:
            print(
                "\n >>> check prompt for creating algorithm using [ m1 ] : \n",
                prompt_content,
            )
            print(">>> Press 'Enter' to continue")
            input()

        code_all, algorithm = self._get_alg(prompt_content)

        if self.debug_mode:
            print("\n >>> check designed algorithm: \n", algorithm)
            print("\n >>> check designed code: \n", code_all)
            print(">>> Press 'Enter' to continue")
            input()

        return [code_all, algorithm]

    def m2(self, parents: dict[str, str]) -> list[str]:
        """
        Operator 'm2': Create a new algorithm by adjusting parameters
        of the given parent algorithm.

        Args:
            parents: A dictionary with 'algorithm' and 'code'.

        Returns:
            [code_all, algorithm], both strings.
        """
        prompt_content = self.get_prompt_m2(parents)

        if self.debug_mode:
            print(
                "\n >>> check prompt for creating algorithm using [ m2 ] : \n",
                prompt_content,
            )
            print(">>> Press 'Enter' to continue")
            input()

        code_all, algorithm = self._get_alg(prompt_content)

        if self.debug_mode:
            print("\n >>> check designed algorithm: \n", algorithm)
            print("\n >>> check designed code: \n", code_all)
            print(">>> Press 'Enter' to continue")
            input()

        return [code_all, algorithm]

    def m3(self, parents: dict[str, str]) -> list[str]:
        """
        Operator 'm3': Simplify the components of the parent's code.

        Args:
            parents: A dictionary with 'algorithm' and 'code'.

        Returns:
            [code_all, algorithm], both strings.
        """
        prompt_content = self.get_prompt_m3(parents)

        if self.debug_mode:
            print(
                "\n >>> check prompt for creating algorithm using [ m3 ] : \n",
                prompt_content,
            )
            print(">>> Press 'Enter' to continue")
            input()

        code_all, algorithm = self._get_alg(prompt_content)

        if self.debug_mode:
            print("\n >>> check designed algorithm: \n", algorithm)
            print("\n >>> check designed code: \n", code_all)
            print(">>> Press 'Enter' to continue")
            input()

        return [code_all, algorithm]

    def h1(self, parents: list[dict[str, str]]) -> list[str]:
        """
        Operator 'h1': Create a new hybrid algorithm by combining multiple parents.

        Args:
            parents: A list of parent algorithm dicts.

        Returns:
            [code_all, algorithm], both strings.
        """
        prompt_content = self.get_prompt_h1(parents)

        if self.debug_mode:
            print(
                "\n >>> check prompt for creating algorithm using [ h1 ] : \n",
                prompt_content,
            )
            print(">>> Press 'Enter' to continue")
            input()

        code_all, algorithm = self._get_alg(prompt_content)

        if self.debug_mode:
            print("\n >>> check designed algorithm: \n", algorithm)
            print("\n >>> check designed code: \n", code_all)
            print(">>> Press 'Enter' to continue")
            input()

        return [code_all, algorithm]

    def f1(self, parent: dict[str, str], failure_cases: str) -> list[str]:
        """
        Operator 'f1': Improve the algorithm by analyzing known failure cases.

        Args:
            parent: A dictionary with 'algorithm' and 'code'.
            failure_cases: A string describing the failure scenarios.

        Returns:
            [code_all, algorithm], both strings.
        """
        prompt_content = self.get_prompt_f1(parent, failure_cases)

        if self.debug_mode:
            print(
                "\n >>> check prompt for creating algorithm using [ f1 ] : \n",
                prompt_content,
            )
            print(">>> Press 'Enter' to continue")
            input()

        code_all, algorithm = self._get_alg(prompt_content)

        if self.debug_mode:
            print("\n >>> check designed algorithm: \n", algorithm)
            print("\n >>> check designed code: \n", code_all)
            print(">>> Press 'Enter' to continue")
            input()

        return [code_all, algorithm]

    def c1(self, parent: dict[str, str], constraints: str) -> list[str]:
        """
        Operator 'c1': Create a constraint-optimized algorithm based on the parent's code.

        Args:
            parent: A dictionary with 'algorithm' and 'code'.
            constraints: A string describing critical constraints to handle.

        Returns:
            [code_all, algorithm], both strings.
        """
        prompt_content = self.get_prompt_c1(parent, constraints)

        if self.debug_mode:
            print(
                "\n >>> check prompt for creating algorithm using [ c1 ] : \n",
                prompt_content,
            )
            print(">>> Press 'Enter' to continue")
            input()

        code_all, algorithm = self._get_alg(prompt_content)

        if self.debug_mode:
            print("\n >>> check designed algorithm: \n", algorithm)
            print("\n >>> check designed code: \n", code_all)
            print(">>> Press 'Enter' to continue")
            input()

        return [code_all, algorithm]

    def p1(self, parent: dict[str, str], complexity_target: str) -> list[str]:
        """
        Operator 'p1': Increase the complexity of the parent algorithm in a controlled manner.

        Args:
            parent: A dictionary with 'algorithm' and 'code'.
            complexity_target: A string describing how to add complexity.

        Returns:
            [code_all, algorithm], both strings.
        """
        prompt_content = self.get_prompt_p1(parent, complexity_target)

        if self.debug_mode:
            print(
                "\n >>> check prompt for creating algorithm using [ p1 ] : \n",
                prompt_content,
            )
            print(">>> Press 'Enter' to continue")
            input()

        code_all, algorithm = self._get_alg(prompt_content)

        if self.debug_mode:
            print("\n >>> check designed algorithm: \n", algorithm)
            print("\n >>> check designed code: \n", code_all)
            print(">>> Press 'Enter' to continue")
            input()

        return [code_all, algorithm]
