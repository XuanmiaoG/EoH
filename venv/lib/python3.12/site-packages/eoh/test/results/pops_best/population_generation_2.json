{
     "algorithm": "The new algorithm calculates scores by combining a weighted logarithmic decay of remaining capacity, a penalty for bins with remaining capacity close to the item size, a term that prioritizes bins with higher remaining capacity relative to the item size, and a term that penalizes bins with very small remaining capacity.",
     "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the logarithmic decay of remaining capacity\n    log_decay = np.log1p(bins / np.max(bins))\n    \n    # Calculate the penalty for bins with remaining capacity close to the item size\n    penalty = 1 / (1 + np.abs(bins - item))\n    \n    # Calculate the relative capacity term\n    relative_capacity = bins / item\n    \n    # Calculate the penalty for bins with very small remaining capacity\n    small_capacity_penalty = np.where(bins < item * 0.1, 0.1, 1.0)\n    \n    # Combine the terms to calculate the scores\n    scores = log_decay * penalty * relative_capacity * small_capacity_penalty\n    \n    return scores",
     "objective": 0.03924,
     "other_inf": null
}