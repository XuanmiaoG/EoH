import numpy as np
import importlib
from .get_instance import GetData
from .prompts import GetPrompts
import types
import warnings
import sys
import numba  # make sure numba is imported

class KNAPSACK():
    def __init__(self):
        # Load a default instance set (e.g., instances with 100 items)
        getdata = GetData()
        # We assume get_instances accepts a string (e.g., "100") indicating the instance size/type.
        self.instances, self.lb = getdata.get_instances("100")
        self.prompts = GetPrompts()

    def greedy_knapsack(self, items, capacity, score_func):
        """
        Given a list of items (each a dict with keys 'weight' and 'value') and a knapsack capacity,
        this function uses the candidate heuristic (score_func) to greedily select items.
        """
        remaining_capacity = capacity
        total_value = 0
        available = items.copy()
        while True:
            # Only consider items that can fit into the remaining capacity.
            feasible = [item for item in available if item['weight'] <= remaining_capacity]
            if not feasible:
                break
            scores = []
            for item in feasible:
                # Call the candidate's score function with the item's weight, value, and the current capacity.
                result = score_func(item['weight'], item['value'], remaining_capacity)
                # If the result is callable (e.g. a function), then the candidate did not return a number.
                if callable(result):
                    raise ValueError("Candidate score function did not return a numeric value.")
                # If the result is a numpy array, extract its scalar value.
                if isinstance(result, np.ndarray):
                    result = result.item()
                # Convert the result to a float.
                scores.append(float(result))
            # Select the index of the item with the highest score.
            idx = np.argmax(scores)
            chosen = feasible[idx]
            total_value += chosen['value']
            remaining_capacity -= chosen['weight']
            available.remove(chosen)
        return total_value

    def evaluateGreedy(self, alg) -> float:
        """
        For each knapsack instance, run the greedy_knapsack algorithm using the candidate heuristic.
        Each instance is a dict with keys: 'capacity', 'num_items', 'weights', and 'values'.
        A baseline value (lb) is assumed to be provided (e.g., from a standard greedy algorithm).
        The fitness is defined as the relative improvement of the candidate over the baseline.
        """
        # Retrieve the candidate score function from the provided module.
        score_func = getattr(alg, "score", None)
        if score_func is None:
            raise ValueError("Candidate module does not define a 'score' function.")
        # If the score function is Numba-compiled, try to get the underlying Python function.
        if hasattr(score_func, "py_func"):
            score_func = score_func.py_func

        values = []
        for name, instance in self.instances.items():
            capacity = instance['capacity']
            weights = instance['weights']
            values_arr = instance['values']
            # Build a list of items where each item is a dictionary with keys 'weight' and 'value'
            items = [{'weight': w, 'value': v} for w, v in zip(weights, values_arr)]
            candidate_value = self.greedy_knapsack(items, capacity, score_func)
            values.append(candidate_value)
        avg_value = np.mean(values)
        baseline_avg = np.mean([self.lb[name] for name in self.instances.keys()])
        fitness = (avg_value - baseline_avg) / baseline_avg
        return fitness

    def evaluate(self, code_string):
        """
        This method creates a temporary module from the candidate code string,
        then uses it to evaluate the fitness of the candidate heuristic.
        """
        try:
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                # Create a new module to hold the candidate code.
                heuristic_module = types.ModuleType("heuristic_module")
                exec(code_string, heuristic_module.__dict__)
                sys.modules[heuristic_module.__name__] = heuristic_module
                fitness = self.evaluateGreedy(heuristic_module)
                return fitness
        except Exception as e:
            print("Error during evaluation:", e)
            return None
