{
     "algorithm": "The hybrid algorithm combines the logarithmic and exponential prioritization of bins with just enough space from Algorithm 1, the penalty for large remaining capacities from Algorithm 2, and introduces a novel dynamic weighting mechanism that adjusts the influence of each component based on the remaining capacity to further optimize bin usage.",
     "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    \n    # Logarithm of remaining capacity to prioritize bins with smaller remaining capacity\n    log_capacity = np.log(remaining_capacity + 1)\n    \n    # Exponential of inverse capacity to further prioritize bins with just enough space\n    exp_inverse_capacity = np.exp(1 / (remaining_capacity + 1e-10))\n    \n    # Penalize bins with large remaining capacities\n    penalty = np.where(remaining_capacity > 0, 1 / (remaining_capacity + 1), 0)\n    \n    # Dynamic weighting based on remaining capacity\n    weight_log = np.where(remaining_capacity <= item, 1.5, 1.0)\n    weight_exp = np.where(remaining_capacity <= item, 1.5, 1.0)\n    weight_penalty = np.where(remaining_capacity > item, 1.5, 1.0)\n    \n    # Combine the components with dynamic weights\n    scores = (weight_log * log_capacity) + (weight_exp * exp_inverse_capacity) - (weight_penalty * penalty)\n    \n    return scores",
     "objective": 0.03572,
     "other_inf": null
}