{
     "algorithm": "The new algorithm assigns a score to each bin based on a weighted combination of the bin's remaining capacity, the item size, the bin's current utilization, a penalty for bins with remaining capacity close to the item size, and a reward for bins with higher utilization, while prioritizing bins with lower remaining capacity and penalizing unused bins.",
     "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate utilization of each bin (1 - remaining_capacity / max_capacity)\n    max_capacity = bins.max()  # Assume max capacity is the largest bin capacity\n    utilizations = 1 - (bins / max_capacity)\n    \n    # Calculate the difference between bin capacity and item size\n    capacity_diff = bins - item\n    \n    # Calculate a penalty term for bins with remaining capacity close to the item size\n    penalty = np.exp(-np.abs(capacity_diff) / (max_capacity * 0.1))  # Adjust 0.1 for sensitivity\n    \n    # Calculate a reward term for bins with higher utilization\n    reward = np.exp(utilizations)\n    \n    # Calculate the score as a weighted combination of utilization, capacity difference, penalty, and reward\n    # Lower remaining capacity, higher utilization, smaller capacity difference, and lower penalty get higher scores\n    scores = (1 / (capacity_diff + 1e-9)) * reward * (1 / (penalty + 1e-9)) * (1 - utilizations)\n    \n    # Set score to -infinity for bins with remaining capacity equal to max capacity (unused bins)\n    scores[bins == max_capacity] = -np.inf\n    \n    return scores",
     "objective": 0.02878,
     "other_inf": null
}