[
     {
          "algorithm": "The new algorithm assigns a score to each bin based on a weighted combination of the bin's remaining capacity, the item size, the bin's current utilization, a penalty for bins with remaining capacity close to the item size, and a reward for bins with higher utilization, while prioritizing bins with lower remaining capacity and penalizing unused bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate utilization of each bin (1 - remaining_capacity / max_capacity)\n    max_capacity = bins.max()  # Assume max capacity is the largest bin capacity\n    utilizations = 1 - (bins / max_capacity)\n    \n    # Calculate the difference between bin capacity and item size\n    capacity_diff = bins - item\n    \n    # Calculate a penalty term for bins with remaining capacity close to the item size\n    penalty = np.exp(-np.abs(capacity_diff) / (max_capacity * 0.1))  # Adjust 0.1 for sensitivity\n    \n    # Calculate a reward term for bins with higher utilization\n    reward = np.exp(utilizations)\n    \n    # Calculate the score as a weighted combination of utilization, capacity difference, penalty, and reward\n    # Lower remaining capacity, higher utilization, smaller capacity difference, and lower penalty get higher scores\n    scores = (1 / (capacity_diff + 1e-9)) * reward * (1 / (penalty + 1e-9)) * (1 - utilizations)\n    \n    # Set score to -infinity for bins with remaining capacity equal to max capacity (unused bins)\n    scores[bins == max_capacity] = -np.inf\n    \n    return scores",
          "objective": 0.02878,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates scores for bins based on a combination of bin utilization, a penalty for bins with remaining capacity close to the item size, a reward for bins with higher utilization, and a balance term that prioritizes bins with utilization close to a target value, while also incorporating a dynamic weight adjustment based on the item size and bin capacities.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate utilization of each bin (1 - remaining_capacity / max_capacity)\n    max_capacity = bins.max()  # Assume max capacity is the largest bin capacity\n    utilizations = 1 - (bins / max_capacity)\n    \n    # Calculate the difference between bin capacity and item size\n    capacity_diff = bins - item\n    \n    # Calculate a penalty term for bins with remaining capacity close to the item size\n    penalty = np.exp(-np.abs(capacity_diff) / (max_capacity * 0.1))  # Adjust 0.1 for sensitivity\n    \n    # Calculate a reward term for bins with higher utilization\n    reward = np.exp(utilizations)\n    \n    # Calculate a balance term to prioritize bins with utilization close to a target value (e.g., 60%)\n    target_utilization = 0.6\n    balance = np.exp(-np.abs(utilizations - target_utilization))\n    \n    # Dynamic weight adjustment based on item size and bin capacities\n    weight = np.exp(-item / max_capacity)  # Higher weight for smaller items\n    \n    # Calculate the score as a weighted combination of utilization, capacity difference, penalty, reward, and balance\n    scores = (1 / (capacity_diff + 1e-9)) * reward * (1 / (penalty + 1e-9)) * balance * (1 - utilizations) * weight\n    \n    # Set score to -infinity for bins with remaining capacity equal to max capacity (unused bins)\n    scores[bins == max_capacity] = -np.inf\n    \n    return scores",
          "objective": 0.02888,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm assigns a score to each bin based on a combination of the bin's remaining capacity, the item size, the bin's current utilization, a penalty for bins with remaining capacity close to the item size, a reward for bins with high utilization, and an additional term that prioritizes bins with lower remaining capacity while penalizing unused bins and bins with large remaining capacity.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate utilization of each bin (remaining_capacity / max_capacity)\n    max_capacity = bins.max()  # Assume max capacity is the largest bin capacity\n    utilizations = bins / max_capacity\n    \n    # Calculate the difference between bin capacity and item size\n    capacity_diff = bins - item\n    \n    # Calculate a penalty term for bins with remaining capacity close to the item size\n    penalty = np.exp(-np.abs(capacity_diff) / (max_capacity * 0.05))  # Adjusted sensitivity\n    \n    # Calculate a reward term for bins with high utilization\n    reward = np.exp(utilizations * 2)  # Increased weight for high utilization\n    \n    # Calculate a term that prioritizes bins with lower remaining capacity\n    capacity_priority = 1 / (bins + 1e-9)\n    \n    # Calculate a penalty term for bins with large remaining capacity\n    large_capacity_penalty = np.exp(-bins / (max_capacity * 0.2))  # Penalize large remaining capacity\n    \n    # Calculate the score as a weighted combination of utilization, capacity difference, penalty, reward, capacity priority, and large capacity penalty\n    scores = (1 / (capacity_diff + 1e-9)) * reward * (1 / (penalty + 1e-9)) * capacity_priority * large_capacity_penalty\n    \n    # Set score to -infinity for bins with remaining capacity equal to max capacity (unused bins)\n    scores[bins == max_capacity] = -np.inf\n    \n    return scores",
          "objective": 0.02898,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm assigns a score to each bin based on a combination of the bin's remaining capacity, the item size, a penalty for bins with remaining capacity close to the item size, a reward for bins with high utilization, and a dynamic weight that prioritizes bins with lower remaining capacity while penalizing unused bins and balancing the trade-off between utilization and capacity difference.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate utilization of each bin (1 - remaining_capacity / max_capacity)\n    max_capacity = bins.max()  # Assume max capacity is the largest bin capacity\n    utilizations = 1 - (bins / max_capacity)\n    \n    # Calculate the difference between bin capacity and item size\n    capacity_diff = bins - item\n    \n    # Calculate a penalty term for bins with remaining capacity close to the item size\n    penalty = np.exp(-np.abs(capacity_diff) / (max_capacity * 0.05))  # Adjust 0.05 for sensitivity\n    \n    # Calculate a reward term for bins with high utilization\n    reward = np.exp(utilizations * 2)  # Amplify the reward for high utilization\n    \n    # Calculate a dynamic weight based on the remaining capacity and utilization\n    weight = np.exp(-capacity_diff / (max_capacity * 0.2)) * utilizations\n    \n    # Calculate the score as a weighted combination of utilization, capacity difference, penalty, and reward\n    scores = (1 / (capacity_diff + 1e-9)) * reward * (1 / (penalty + 1e-9)) * weight\n    \n    # Set score to -infinity for bins with remaining capacity equal to max capacity (unused bins)\n    scores[bins == max_capacity] = -np.inf\n    \n    return scores",
          "objective": 0.02928,
          "other_inf": null
     }
]