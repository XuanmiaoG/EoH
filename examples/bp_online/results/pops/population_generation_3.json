[
     {
          "algorithm": "The new algorithm calculates scores for bins by combining a logarithmic penalty for remaining capacity, a dynamic weight based on the inverse of remaining capacity, and a quadratic normalization factor, ensuring bins with smaller remaining capacities are prioritized while avoiding over-penalizing nearly full bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the normalized remaining capacity after placing the item\n    remaining_capacity = bins - item\n    normalized_capacity = (remaining_capacity / bins) ** 2\n    \n    # Calculate a logarithmic penalty based on the bin's remaining capacity\n    penalty = np.where(remaining_capacity > 0, np.log1p(remaining_capacity), -np.inf)\n    \n    # Calculate a dynamic weight based on the inverse of the bin's remaining capacity\n    weight = 1 / (remaining_capacity + 1e-10)\n    \n    # Calculate the score as a combination of normalized capacity, penalty, and weight\n    scores = normalized_capacity * penalty * weight\n    \n    return scores",
          "objective": 0.01992,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates scores for bins by combining a sigmoid-based penalty for remaining capacity, a dynamic weight based on the exponential decay of remaining capacity, and a normalized capacity factor, ensuring bins with smaller remaining capacities are prioritized while avoiding over-penalizing nearly full bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the normalized remaining capacity after placing the item\n    remaining_capacity = bins - item\n    normalized_capacity = remaining_capacity / bins\n    \n    # Calculate a sigmoid-based penalty based on the bin's remaining capacity\n    penalty = np.where(remaining_capacity > 0, 1 / (1 + np.exp(-remaining_capacity / item)), -np.inf)\n    \n    # Calculate a dynamic weight based on the exponential decay of the bin's remaining capacity\n    weight = np.exp(-remaining_capacity / item)\n    \n    # Calculate the score as a combination of normalized capacity, penalty, and weight\n    scores = normalized_capacity * penalty * weight\n    \n    return scores",
          "objective": 0.03049,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the normalized remaining capacity after placing the item\n    remaining_capacity = bins - item\n    normalized_capacity = remaining_capacity / bins\n    \n    # Calculate a hyperbolic tangent penalty based on the bin's remaining capacity\n    penalty = np.where(remaining_capacity > 0, np.tanh(remaining_capacity / item), -np.inf)\n    \n    # Calculate a dynamic weight based on the Gaussian decay of the bin's remaining capacity\n    weight = np.exp(-(remaining_capacity / item) ** 2)\n    \n    # Calculate the score as a combination of normalized capacity, penalty, and weight\n    scores = normalized_capacity * penalty * weight\n    \n    return scores",
          "objective": 0.03864,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the normalized remaining capacity after placing the item\n    remaining_capacity = bins - item\n    normalized_capacity = remaining_capacity / bins\n    \n    # Calculate a dynamic penalty based on the bin's remaining capacity and item size\n    penalty = np.where(remaining_capacity > 0, np.exp(-remaining_capacity / item), -np.inf)\n    \n    # Calculate a weight based on the inverse of the bin's remaining capacity\n    weight = 1 / (remaining_capacity + 1e-9)\n    \n    # Calculate the score as a combination of normalized capacity, penalty, and weight\n    scores = normalized_capacity * penalty * weight\n    \n    return scores",
          "objective": 0.03984,
          "other_inf": null
     }
]