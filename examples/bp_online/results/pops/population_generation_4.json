[
     {
          "algorithm": "The hybrid algorithm combines the logarithmic and exponential prioritization of bins with just enough space from Algorithm 1, the penalty for large remaining capacities from Algorithm 2, and introduces a novel dynamic weighting mechanism that adjusts the influence of each component based on the remaining capacity to further optimize bin usage.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    \n    # Logarithm of remaining capacity to prioritize bins with smaller remaining capacity\n    log_capacity = np.log(remaining_capacity + 1)\n    \n    # Exponential of inverse capacity to further prioritize bins with just enough space\n    exp_inverse_capacity = np.exp(1 / (remaining_capacity + 1e-10))\n    \n    # Penalize bins with large remaining capacities\n    penalty = np.where(remaining_capacity > 0, 1 / (remaining_capacity + 1), 0)\n    \n    # Dynamic weighting based on remaining capacity\n    weight_log = np.where(remaining_capacity <= item, 1.5, 1.0)\n    weight_exp = np.where(remaining_capacity <= item, 1.5, 1.0)\n    weight_penalty = np.where(remaining_capacity > item, 1.5, 1.0)\n    \n    # Combine the components with dynamic weights\n    scores = (weight_log * log_capacity) + (weight_exp * exp_inverse_capacity) - (weight_penalty * penalty)\n    \n    return scores",
          "objective": 0.03572,
          "other_inf": null
     },
     {
          "algorithm": "The hybrid algorithm combines the logarithmic and exponential prioritization of bins with just enough space from Algorithm 1, the penalty for large remaining capacities from Algorithm 2, and introduces a novel dynamic weighting mechanism that adjusts the influence of each component based on the remaining capacity to further optimize bin usage, while also incorporating a novel adaptive thresholding mechanism to dynamically adjust the scoring based on the distribution of remaining capacities.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    \n    # Logarithm of remaining capacity to prioritize bins with smaller remaining capacity\n    log_capacity = np.log(remaining_capacity + 1)\n    \n    # Exponential of inverse capacity to further prioritize bins with just enough space\n    exp_inverse_capacity = np.exp(1 / (remaining_capacity + 1e-10))\n    \n    # Penalize bins with large remaining capacities\n    penalty = np.where(remaining_capacity > 0, 1 / (remaining_capacity + 1), 0)\n    \n    # Dynamic weighting based on remaining capacity\n    weight_log = np.where(remaining_capacity <= item, 1.5, 1.0)\n    weight_exp = np.where(remaining_capacity <= item, 1.5, 1.0)\n    weight_penalty = np.where(remaining_capacity > item, 1.5, 1.0)\n    \n    # Adaptive thresholding mechanism\n    mean_capacity = np.mean(remaining_capacity)\n    std_capacity = np.std(remaining_capacity)\n    adaptive_threshold = mean_capacity - std_capacity\n    \n    # Adjust weights based on adaptive threshold\n    weight_log = np.where(remaining_capacity <= adaptive_threshold, 2.0, weight_log)\n    weight_exp = np.where(remaining_capacity <= adaptive_threshold, 2.0, weight_exp)\n    weight_penalty = np.where(remaining_capacity > adaptive_threshold, 2.0, weight_penalty)\n    \n    # Combine the components with dynamic weights\n    scores = (weight_log * log_capacity) + (weight_exp * exp_inverse_capacity) - (weight_penalty * penalty)\n    \n    return scores",
          "objective": 0.03662,
          "other_inf": null
     },
     {
          "algorithm": "The novel algorithm combines a sigmoid-based prioritization of bins with just enough space, a quadratic penalty for large remaining capacities, and a dynamic scaling mechanism that adjusts the influence of each component based on the ratio of the item size to the remaining capacity.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    \n    # Sigmoid-based prioritization to favor bins with just enough space\n    sigmoid_priority = 1 / (1 + np.exp(-(remaining_capacity - item)))\n    \n    # Quadratic penalty for large remaining capacities\n    penalty = np.where(remaining_capacity > 0, (remaining_capacity ** 2) / (item ** 2 + 1e-10), 0)\n    \n    # Dynamic scaling based on the ratio of item size to remaining capacity\n    ratio = item / (remaining_capacity + 1e-10)\n    scale_priority = np.where(ratio <= 1, 1.5, 1.0)\n    scale_penalty = np.where(ratio > 1, 1.5, 1.0)\n    \n    # Combine the components with dynamic scaling\n    scores = (scale_priority * sigmoid_priority) - (scale_penalty * penalty)\n    \n    return scores",
          "objective": 0.03693,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm assigns scores to bins by combining a weighted sum of the logarithm of the remaining capacity, the exponential of the inverse of the remaining capacity, and a dynamic penalty term that increases with the difference between the bin's remaining capacity and the item size, ensuring bins with just enough space for the item are prioritized while discouraging the use of bins with excessive remaining capacity.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    remaining_capacity = bins - item\n    \n    # Logarithm of remaining capacity to prioritize bins with smaller remaining capacity\n    log_capacity = np.log(remaining_capacity + 1)\n    \n    # Exponential of inverse capacity to further prioritize bins with just enough space\n    exp_inverse_capacity = np.exp(1 / (remaining_capacity + 1e-10))\n    \n    # Dynamic penalty term based on the difference between remaining capacity and item size\n    penalty = np.where(remaining_capacity > item, (remaining_capacity - item) ** 2, 0)\n    \n    # Combine the components to compute the final score\n    scores = log_capacity + exp_inverse_capacity - penalty\n    \n    return scores",
          "objective": 0.03854,
          "other_inf": null
     }
]