[
     {
          "algorithm": "The algorithm assigns a score to each bin based on a weighted combination of the bin's remaining capacity, the item size, and a penalty for bins with large remaining capacities, ensuring that bins are filled efficiently to minimize the total number of used bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the remaining capacity after placing the item\n    remaining_capacity = bins - item\n    \n    # Penalize bins with large remaining capacities to encourage filling\n    penalty = np.where(remaining_capacity > 0, 1 / (remaining_capacity + 1e-9), 0)\n    \n    # Calculate the score as a weighted combination of remaining capacity and penalty\n    scores = (1 / (remaining_capacity + 1e-9)) * penalty\n    \n    # Set the score to 0 for bins that cannot fit the item\n    scores[bins < item] = 0\n    \n    return scores",
          "objective": 0.05071,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm assigns scores to bins by considering the ratio of the remaining capacity to the item size, the inverse of the remaining capacity, and a penalty for bins with maximum capacity, ensuring efficient bin usage and minimizing the total number of bins used.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the ratio of remaining capacity to item size\n    ratio = bins / item\n    # Calculate the inverse of the remaining capacity\n    inv_capacity = 1 / bins\n    # Penalize bins with maximum capacity (remaining capacity equals maximum capacity)\n    penalty = np.where(bins == bins.max(), 0, 1)\n    # Combine the factors to compute the score\n    scores = ratio * inv_capacity * penalty\n    return scores",
          "objective": 0.05675,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm assigns a score to each bin based on a weighted combination of the bin's remaining capacity, the item size, and a penalty for bins with remaining capacity equal to their maximum capacity, aiming to minimize the number of used bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the remaining capacity ratio\n    capacity_ratio = bins / item\n    \n    # Penalize bins with remaining capacity equal to their maximum capacity\n    penalty = np.where(bins == bins.max(), 0, 1)\n    \n    # Combine the capacity ratio and penalty into a score\n    scores = capacity_ratio * penalty\n    \n    return scores",
          "objective": 0.13211,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm assigns an item to a bin by scoring each feasible bin based on a weighted combination of the bin's remaining capacity, the item size, and the inverse of the bin's capacity, ensuring that bins with less remaining capacity are prioritized to minimize fragmentation and the number of used bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the remaining capacity after placing the item\n    remaining_capacity = bins - item\n    \n    # Calculate the inverse of the bin's capacity (to prioritize bins with less remaining capacity)\n    inverse_capacity = 1 / bins\n    \n    # Calculate the score as a weighted combination of remaining capacity and inverse capacity\n    scores = remaining_capacity * 0.6 + inverse_capacity * 0.4\n    \n    # If the remaining capacity equals the maximum capacity, set the score to -infinity to avoid using it\n    scores[bins == item] = -np.inf\n    \n    return scores",
          "objective": 1.51534,
          "other_inf": null
     }
]