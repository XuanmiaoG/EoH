[
     {
          "algorithm": "The algorithm assigns a score to each bin based on a weighted combination of the bin's remaining capacity, the item size, and a penalty for bins with remaining capacity equal to their maximum capacity, aiming to minimize the number of used bins while ensuring efficient packing.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the penalty for bins with remaining capacity equal to their maximum capacity\n    max_capacity = bins.max()\n    penalty = np.where(bins == max_capacity, -np.inf, 0)\n    \n    # Calculate the score based on the remaining capacity, item size, and penalty\n    scores = (bins - item) / bins + penalty\n    \n    return scores",
          "objective": 0.13211,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm assigns a score to each bin based on a weighted combination of the bin's remaining capacity, the item size, and a penalty for bins with remaining capacity equal to their maximum capacity, aiming to minimize the number of used bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Define weights for the scoring function\n    weight_capacity = 0.6\n    weight_item = 0.3\n    weight_penalty = 0.1\n    \n    # Calculate the score for each bin\n    scores = weight_capacity * (bins - item) / bins  # Favor bins with less remaining capacity\n    scores += weight_item * (item / bins)  # Favor bins where the item fits well\n    scores -= weight_penalty * (bins == bins.max())  # Penalize bins with maximum remaining capacity\n    \n    return scores",
          "objective": 0.38123,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm assigns a score to each bin based on a weighted combination of the bin's remaining capacity, the item size, and a penalty for bins with large remaining capacities, ensuring that bins with just enough capacity for the item are prioritized to minimize the number of used bins.",
          "code": "import numpy as np\n\ndef score(item, bins):\n    # Calculate the difference between bin capacities and the item size\n    diff = bins - item\n    # Penalize bins with large remaining capacities using an exponential decay\n    penalty = np.exp(-diff / item)\n    # Calculate scores as a weighted combination of the difference and penalty\n    scores = diff * penalty\n    return scores",
          "objective": 0.38787,
          "other_inf": null
     }
]