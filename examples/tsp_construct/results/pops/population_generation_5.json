[
     {
          "algorithm": "The new algorithm selects the next node by choosing the unvisited node that minimizes the sum of the distance from the current node to the unvisited node and the distance from the unvisited node to the destination node, weighted by a factor inversely proportional to the distance from the unvisited node to the destination node.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_score = float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        if distance_matrix[node, destination_node] == 0:\n            score = float('inf')\n        else:\n            score = (distance_matrix[current_node, node] + distance_matrix[node, destination_node]) / distance_matrix[node, destination_node]\n        \n        if score < min_score:\n            min_score = score\n            next_node = node\n    \n    return next_node",
          "objective": 6.30341,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm selects the next node by choosing the unvisited node that minimizes the ratio of the distance from the current node to the unvisited node to the average distance from the unvisited node to all other unvisited nodes.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_ratio = float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        avg_distance_to_others = np.mean([distance_matrix[node, other] for other in unvisited_nodes if other != node])\n        if avg_distance_to_others == 0:\n            ratio = float('inf')\n        else:\n            ratio = distance_matrix[current_node, node] / avg_distance_to_others\n        \n        if ratio < min_ratio:\n            min_ratio = ratio\n            next_node = node\n    \n    return next_node",
          "objective": 6.34985,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm selects the next node by choosing the unvisited node that maximizes the ratio of the distance from the current node to the destination node over the distance from the current node to the unvisited node.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    max_ratio = -float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        if distance_matrix[current_node, node] != 0:\n            ratio = distance_matrix[current_node, destination_node] / distance_matrix[current_node, node]\n            if ratio > max_ratio:\n                max_ratio = ratio\n                next_node = node\n    \n    return next_node",
          "objective": 6.60788,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm selects the next node by choosing the unvisited node that minimizes the sum of the distance from the current node to the unvisited node and the distance from the unvisited node to the destination node, weighted by a factor proportional to the distance from the current node to the unvisited node.",
          "code": "import numpy as np\n\ndef select_next_node(current_node, destination_node, unvisited_nodes, distance_matrix):\n    min_score = float('inf')\n    next_node = None\n    \n    for node in unvisited_nodes:\n        if distance_matrix[current_node, node] == 0:\n            score = float('inf')\n        else:\n            score = (distance_matrix[current_node, node] + distance_matrix[node, destination_node]) * distance_matrix[current_node, node]\n        \n        if score < min_score:\n            min_score = score\n            next_node = node\n    \n    return next_node",
          "objective": 6.79893,
          "other_inf": null
     }
]