[
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and its potential contribution to the remaining capacity, ensuring that items that fit well and provide high value are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Score is a combination of value-to-weight ratio and the fraction of remaining capacity used\n    value_to_weight = value / weight\n    capacity_usage = weight / remaining_capacity\n    score = value_to_weight * (1 - capacity_usage)\n    return score",
          "objective": -0.03045,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm scores each item based on the ratio of its value to the square of its weight, adjusted by the remaining capacity, ensuring that items with higher value and lower weight are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # {The algorithm scores each item based on the ratio of its value to the square of its weight, adjusted by the remaining capacity, ensuring that items with higher value and lower weight are prioritized.}\n    score = (value / (weight ** 2)) * remaining_capacity\n    return score",
          "objective": -0.02527,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on the exponential decay of its weight relative to the remaining capacity, combined with its value-to-weight ratio, ensuring that items with higher value density and lower weight relative to the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight = value / weight\n    weight_ratio = weight / remaining_capacity\n    score = value_to_weight * np.exp(-weight_ratio)\n    return score",
          "objective": -0.02192,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and a penalty for its weight relative to the remaining capacity, ensuring that items with higher value density and lower weight are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_density = value / weight\n    weight_penalty = weight / remaining_capacity\n    score = value_density - weight_penalty\n    return score",
          "objective": -0.01949,
          "other_inf": null
     }
]