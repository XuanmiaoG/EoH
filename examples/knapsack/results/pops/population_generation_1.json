[
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value, weight, and the remaining capacity, prioritizing items that maximize the value while minimizing the wasted capacity in the knapsack.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    wasted_capacity = remaining_capacity - weight\n    score = value * (1 - wasted_capacity / remaining_capacity)\n    return score",
          "objective": -0.33841,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value and lower weight are prioritized while considering the knapsack's current capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    penalty = np.exp(-remaining_capacity / weight)\n    score = value_to_weight_ratio * penalty\n    return score",
          "objective": -0.32138,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm scores each item based on a combination of its value, weight, and the remaining capacity, using an exponential function to prioritize items that maximize value while considering the ratio of remaining capacity to weight.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_contribution = value * np.exp(remaining_capacity / weight)\n    score = value_contribution / (weight ** 2)\n    return score",
          "objective": -0.07142,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value-to-weight ratios and those that fit better in the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    penalty = (remaining_capacity - weight) / remaining_capacity\n    score = value_to_weight_ratio * penalty\n    return score",
          "objective": -0.01835,
          "other_inf": null
     }
]