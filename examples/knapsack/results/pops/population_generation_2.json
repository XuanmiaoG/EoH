[
     {
          "algorithm": "The algorithm calculates a score for an item by combining its value-to-weight ratio with an exponential decay factor that prioritizes items that leave the remaining capacity as close as possible to zero, ensuring efficient utilization of the knapsack's capacity.",
          "code": "import numpy as np\nfrom numba import jit\n\n@jit(nopython=True)\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -np.inf  # Item cannot fit, assign lowest possible score\n    value_to_weight = value / weight\n    decay_factor = np.exp(-(remaining_capacity - weight))  # Exponential decay for unused capacity\n    score = value_to_weight * decay_factor\n    return score",
          "objective": -0.54979,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates a score by combining the value-to-weight ratio with an exponential decay factor that prioritizes items leaving the remaining capacity as close as possible to a target fraction of 0.5 of the total capacity, aiming for balanced utilization of the knapsack.",
          "code": "import numpy as np\nfrom numba import jit\n\n@jit(nopython=True)\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -np.inf  # Item cannot fit, assign lowest possible score\n    value_to_weight = value / weight\n    target_fraction = 0.5  # Target fraction of remaining capacity to leave unused\n    decay_factor = np.exp(-abs((remaining_capacity - weight) - target_fraction * remaining_capacity))\n    score = value_to_weight * decay_factor\n    return score",
          "objective": -0.54169,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a score for an item by combining its value-to-weight ratio with an exponential decay factor that prioritizes items that leave the remaining capacity as close as possible to a target fraction of the total capacity, ensuring efficient utilization of the knapsack.",
          "code": "import numpy as np\nfrom numba import jit\n\n@jit(nopython=True)\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -np.inf  # Item cannot fit, assign lowest possible score\n    value_to_weight = value / weight\n    target_fraction = 0.2  # Target fraction of remaining capacity to leave unused\n    decay_factor = np.exp(-abs((remaining_capacity - weight) - target_fraction * remaining_capacity))\n    score = value_to_weight * decay_factor\n    return score",
          "objective": -0.53662,
          "other_inf": null
     },
     {
          "algorithm": "```",
          "code": "import numpy as np\nfrom numba import jit\n\n@jit(nopython=True)\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -np.inf  # Item cannot fit, assign lowest possible score\n    value_to_weight = value / weight\n    capacity_utilization = (remaining_capacity - weight) / remaining_capacity\n    score = value_to_weight * (1 - capacity_utilization) ** 2\n    return score",
          "objective": -0.39255,
          "other_inf": null
     }
]