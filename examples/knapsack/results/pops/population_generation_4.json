[
     {
          "algorithm": "The algorithm scores each item based on the ratio of its value to the exponential of its weight, adjusted by the remaining capacity, ensuring that items with higher value and lower weight are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # {The algorithm scores each item based on the ratio of its value to the exponential of its weight, adjusted by the remaining capacity, ensuring that items with higher value and lower weight are prioritized.}\n    score = (value / np.exp(weight)) * remaining_capacity\n    return score",
          "objective": -0.07916,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm scores each item based on the exponential scaling of its value, adjusted by the ratio of its remaining capacity to its weight, ensuring that items with higher value and lower weight relative to the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    capacity_ratio = remaining_capacity / weight\n    score = np.exp(value) * capacity_ratio\n    return score",
          "objective": -0.07185,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm scores each item based on the logarithmic scaling of its value, adjusted by the ratio of its weight to the remaining capacity, ensuring that items with higher value and lower weight relative to the remaining capacity are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    weight_ratio = weight / remaining_capacity\n    score = np.log(value + 1) / (weight_ratio + 1e-9)\n    return score",
          "objective": -0.04491,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and its potential contribution to the remaining capacity, ensuring that items that fit well and provide high value are prioritized.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    # Score is a combination of value-to-weight ratio and the fraction of remaining capacity used\n    value_to_weight = value / weight\n    capacity_usage = weight / remaining_capacity\n    score = value_to_weight * (1 - capacity_usage)\n    return score",
          "objective": -0.03045,
          "other_inf": null
     }
]