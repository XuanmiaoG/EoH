[
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value, weight, and the remaining capacity, prioritizing items that maximize the value while considering the exponential decay of the remaining capacity relative to the item's weight.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    decay_factor = np.exp(-remaining_capacity / weight)\n    score = value * decay_factor\n    return score",
          "objective": -0.40033,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value, weight, and the remaining capacity, prioritizing items that maximize the value while minimizing the wasted capacity in the knapsack.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    wasted_capacity = remaining_capacity - weight\n    score = value * (1 - wasted_capacity / remaining_capacity)\n    return score",
          "objective": -0.33841,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on a combination of its value-to-weight ratio and a penalty term that accounts for the remaining capacity, ensuring that items with higher value and lower weight are prioritized while considering the knapsack's current capacity.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    value_to_weight_ratio = value / weight\n    penalty = np.exp(-remaining_capacity / weight)\n    score = value_to_weight_ratio * penalty\n    return score",
          "objective": -0.32138,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm is a greedy approach that scores each item based on an exponential decay function of the remaining capacity after including the item, prioritizing items that maximize the value while leaving as much remaining capacity as possible for future items.",
          "code": "import numpy as np\n\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -1e9\n    remaining_after_inclusion = remaining_capacity - weight\n    decay_factor = np.exp(-remaining_after_inclusion / remaining_capacity)\n    score = value * decay_factor\n    return score",
          "objective": -0.09992,
          "other_inf": null
     }
]