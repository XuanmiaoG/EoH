[
     {
          "algorithm": "The new algorithm calculates the score by combining the item's value-to-weight ratio with an exponential decay factor based on the remaining capacity, prioritizing items that are valuable and have a weight that is a significant fraction of the remaining capacity.",
          "code": "import numpy as np\nfrom numba import jit\n\n@jit(nopython=True)\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -np.inf  # Item cannot fit, assign lowest possible score\n    score = (value / weight) * np.exp(-remaining_capacity / (weight + 1))\n    return score",
          "objective": -0.47048,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by combining the item's value with a hyperbolic tangent function that scales based on the ratio of the item's weight to the remaining capacity, prioritizing items that balance high value and efficient use of capacity.",
          "code": "import numpy as np\nfrom numba import jit\n\n@jit(nopython=True)\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -np.inf  # Item cannot fit, assign lowest possible score\n    ratio = weight / remaining_capacity\n    score = value * np.tanh(1 / (ratio + 1e-9))  # Avoid division by zero\n    return score",
          "objective": -0.04466,
          "other_inf": null
     },
     {
          "algorithm": "The new algorithm calculates the score by combining the item's value-to-weight ratio with a logarithmic scaling factor based on the remaining capacity, prioritizing items that are both valuable and lightweight relative to the remaining capacity.",
          "code": "import numpy as np\nfrom numba import jit\n\n@jit(nopython=True)\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -np.inf  # Item cannot fit, assign lowest possible score\n    score = (value / weight) * np.log(remaining_capacity / (weight + 1))\n    return score",
          "objective": -0.02145,
          "other_inf": null
     },
     {
          "algorithm": "The algorithm calculates a score for an item by combining its value with an exponential decay factor based on the item's weight relative to the remaining capacity, prioritizing items that offer high value while leaving more room for future items.",
          "code": "import numpy as np\nfrom numba import jit\n\n@jit(nopython=True)\ndef score(weight, value, remaining_capacity):\n    if weight > remaining_capacity:\n        return -np.inf  # Item cannot fit, assign lowest possible score\n    decay_factor = np.exp(-weight / remaining_capacity)\n    score = value * decay_factor\n    return score",
          "objective": -0.01706,
          "other_inf": null
     }
]